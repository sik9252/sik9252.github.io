---
title: JS ES6 - var, let, const
date: 2022-07-12 19:51 + 0900
category: [Javascript ES6]
---

## var, let, const 특징 한 눈에 보기

| 종류  | 재선언 | 재할당 | 범위 |
| ----- | ------ | ------ | ---- |
| var   | O      | O      | 함수 |
| let   | X      | O      | 블록 |
| const | X      | X      | 블록 |

<br>

## var의 사용을 지양하는 이유

1. 같은 이름을 가진 변수의 **중복 생성**(재선언)이 가능하므로 예상하지 못한 값을 반환할 수 있다. (협업에도 방해될듯)
2. 정의된 변수가 **함수 레벨의 스코프**를 가진다. 따라서 함수 외부에서 선언한 변수는 모두 전역 변수가 되어 외부에서도 참조가 가능하다.
3. var 키워드를 생략하고 값을 할당하면 **암묵적 전역 변수를 양산**할 가능성이 있다.
4. **변수 호이스팅**에 의해 변수를 선언하기 전에도 참조할 수 있으며 undefined로 초기화 된다.

이처럼 var를 사용하는 것을 지양하는 가장 큰 이유는 `전역 변수로 인한 문제` 때문인데, 이는 유효 범위가 넓어 어디에서 어떤식으로 사용되는 변수들인지 파악하는 것이 힘들다. 또한 var를 사용한 변수는 재선언이 가능하므로 의도치 않게 값이 변경될 수도 있기 때문에 버그가 발생할 위험이 높고, 복잡성도 증가된다.

<br>

## 그래서 나온 let, const

### (해결 1) 변수 중복 선언 불가

let과 const는 모두 변수의 재선언이 불가하지만, let은 "재할당"은 가능하다. const는 재할당도 불가능하다.

또한, const는 반드시 `선언과 초기화를 동시에 진행`해야 한다.
다만, 주의할 점은 "완전한 불변"을 의미하지는 않는다. 따라서

```js
const Obj = { name: "Lee" };
Obj.name = "Park";
```

const로 선언한 객체여도 이와 같은 오브젝트 내의 프로퍼티 변경은 가능하다. 이것을 완전 불변으로 만들고 싶다면 Object.freeze(객체명)를 사용해야 한다.

### (해결 2) 블록 레벨 스코프를 가지도록 함

let, const로 선언한 변수는 블록 레벨 스코프(함수, if, for, while, try/catch)를 따른다.

따라서 아래와 같은 경우의 예시를 보면

**var를 사용했을 때**

```js
var a = 1;

if (true) {
  var a = 2;
}

console.log(a); // 2
```

**let을 사용했을 때**

```js
let a = 1;

if (true) {
  let a = 2;
}

console.log(a); // 1
```

var을 사용했을 때는 함수 레벨 스코프이기 때문에 if문 안에 선언한 변수에 의해 값이 변경되어 출력되는데, let을 사용한 경우 블록 레벨 스코프이기 때문에 let a = 2는 if문 안에서만 유효하므로 외부에서 a를 출력해보면 전역으로 선언 된 1이 출력된다.
(const도 동일하다.)

이렇게 해서 전역 변수의 암묵적 양산과 같은 행동을 방지할 수 있다.

### (해결 3) 변수 호이스팅 문제 해결

일단 호이스팅이란, 자바스크립트 엔진이 변수 및 함수의 메모리 공간을 선언 전에 미리 할당하는 작업을 의미한다. 다르게 말하면 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것처럼 행동한다고 할 수 있다.
(var, let, const 뿐 아니라 function, class 키워드를 사용해 선언한 식별자들도 호이스팅 대상에 해당한다.)

자바스크립트에서 변수 선언은 선언 단계, 초기화 단계 그리고 할당 단계를 거쳐 수행된다.

- 선언 단계는 변수를 등록해 자바스크립트 엔진에 변수가 있다는 것을 알려주는 역할이다.
- 초기화 단계는 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해두는 작업을 하는 역할이다.
- 할당 단계는 사용자가 초기화된 메모리에 다른 값을 할당하는 단계이다.

**var**

단계 1) 선언 + 초기화  
단계 2) 할당

단계 1에서 선언 단계와 초기화 단계가 동시에 진행되었으므로 var로 선언한 이후 값을 초기화하지 않고 console.log()로 출력해보면 undefined가 출력된다.

**let**

단계 1) 선언  
단계 2) 일시적 사각지대  
단계 3) 초기화  
단계 4) 할당

> 일시적 사각지대(Temporal Dead Zone: TDZ): 스코프의 시작 지점부터 초기화 단계의 시작 지점까지는 변수를 참조할 수 없는 상태

let으로 선언한 변수는 `선언 단계와 초기화 단계가 분리`되어 진행된다. 따라서 초기화 단계 이전에 호출하면 Reference Error가 발생한다.

```js
let age = 5;

{
  console.log(age); // Reference Error
  let age = 25;
}
```

let은 블록 레벨 스코프를 가지고 있기 때문에 위의 코드와 같은 경우에도 참조 에러를 뱉어낸다.

**const**

const로 선언한 변수는 `선언 단계와 초기화 단계가 동시에 진행`된다. 따라서 선언 및 초기화 이전에 해당 변수를 호출하게 되면 Reference Error가 발생한다.

## 정리

- ES6 이상부터는 var를 사용하지 말자.
- 대부분의 변수에는 const를 활용하며, let은 재할당이 필요한 경우에 한정에 사용하는 습관을 들이자.
