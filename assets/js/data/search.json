[ { "title": "(파이썬)백준 3085번 - 사탕 게임", "url": "/posts/%EB%B0%B1%EC%A4%80-3085-%EC%82%AC%ED%83%95%EA%B2%8C%EC%9E%84/", "categories": "Algorithm, 백준 문제풀이", "tags": "", "date": "2022-08-08 13:28:00 +0900", "snippet": "[ 백준 3085 사탕 게임 ] 문제 바로가기문제 이해하기핵심 1: 주어진 사탕은 N x N 모양으로 놓여있고, 빨강(C), 파랑(P), 초록(Z), 노랑(Y)의 4가지 색의 사탕이 존재한다.핵심 2: 인접한 사탕이면서 서로 다른 색상일 경우에만 두 사탕의 위치를 서로 바꿔준다.핵심 3: 핵심 2의 과정을 한번 수행할 때마다 전체 사탕을 검사하며 모두 같은 색상으로만 이루어져 있는 가장 긴 부분을 찾아 최대 길이를 갱신한다.따라서, 구현해야할 주요 로직은 인접한 사탕이 서로 다른 색상일 경우 두 사탕의 위치를 스왑하는 부분과 주어진 N x N 사탕 배열을 돌면서 같은 색상으로 연속된 사탕의 개수를 검사해 최대 길이를 갱신하는 부분이다.풀이import sysinput=sys.stdin.readline'''같은 색상으로 연속된 사탕의 개수가 최대 몇개인지 검사하는 함수'''def check_candy(): max_candy=0 same_candy=1 # 행 체크 for x in range(N): same_candy=1 for y in range(N-1): if candy[x][y]==candy[x][y+1]: same_candy+=1 else: same_candy=1 # 최대 개수면 갱신 if same_candy &gt; max_candy: max_candy=same_candy # 열 체크 for y in range(N): same_candy=1 for x in range(N-1): if candy[x][y]==candy[x+1][y]: same_candy+=1 else: same_candy=1 # 최대 개수면 갱신 if same_candy &gt; max_candy: max_candy=same_candy return max_candy'''메인 로직'''N=int(input())candy=[list(map(str, input().rstrip())) for _ in range(N)]result=0# 탐색할 방향 설정(좌우하상)dx=[-1,1,0,0]dy=[0,0,-1,1]for x in range(N): for y in range(N): for i in range(4): nx=x+dx[i] ny=y+dy[i] # 배열의 범위를 벗어나는지 체크 if 0&lt;=nx&lt;N and 0&lt;=ny&lt;N: # 인접한 사탕이 다른 색이면 둘이 교체 if candy[x][y]!=candy[nx][ny]: candy[nx][ny],candy[x][y]=candy[x][y],candy[nx][ny] # 교체한 후 배열에서 같은색이 최대로 연결된 사탕 개수 검사해 더 큰 값으로 갱신 result=max(result,check_candy()) # 다른 경우도 전부 검사하기 위해 교체하기 전 상태로 복구 candy[x][y],candy[nx][ny]=candy[nx][ny],candy[x][y]print(result)느낀점구간도 짧게 주어져서 모든 경우를 다 탐색하더라도 시간에 부족함은 없었기 때문에 어려운 문제는 아니였다. 다만, 완전 탐색 문제를 풀 때, 반복문을 도는 부분을 구현하는 부분에서 조금 부족하다는 느낌을 받았다. 나는 반복문이 이중 삼중 중첩이 되면 점점 헷갈리기 시작하는데 이 부분을 잘 보완하기 위한 연습을 많이 해야겠다." }, { "title": "(파이썬)백준 1063번 - 킹", "url": "/posts/%EB%B0%B1%EC%A4%80-1063-%ED%82%B9/", "categories": "Algorithm, 백준 문제풀이", "tags": "", "date": "2022-08-06 03:03:00 +0900", "snippet": "[ 백준 1063 킹 ] 문제 바로가기문제 이해하기핵심 1: 킹과 돌 2개의 물체가 있다.핵심 2: 아래와 같은 명령으로 킹의 움직임을 제어할 수 있다. R : 한 칸 오른쪽으로 L : 한 칸 왼쪽으로 B : 한 칸 아래로 T : 한 칸 위로 RT : 오른쪽 위 대각선으로 LT : 왼쪽 위 대각선으로 RB : 오른쪽 아래 대각선으로 LB : 왼쪽 아래 대각선으로핵심 3: 주어진 명령을 이용해 킹을 움직이다가 체스판 위에 놓여있는 돌과 같은 위치에 놓이게 된다면(겹쳐진다면) 방금 킹이 이동했던 방향으로 돌도 이동시킨다.핵심 4: 킹과 돌 모두 체스판 범위인 8x8을 벗어나게 되는 상황이 발생한다면, 해당 상황을 발생하게한 이동을 무르고 건너뛴다.내가 문제를 읽으며 중요하다고 생각한 부분은 이정도였고, 이 중에서도 핵심 3과 4를 신경써가며 구현해야겠다는 생각을 했다.풀이실패한 코드 보기 import sysinput=sys.stdin.readlinex = [1, -1, 0, 0, 1, -1, 1, -1]y = [0, 0, -1, 1, 1, 1, -1, -1]ctrl = ['R', 'L', 'B', 'T', 'RT', 'LT', 'RB', 'LB']pos_king, pos_stone, N = map(str, input().split())pos_king_x = ord(pos_king[0])pos_king_y = int(pos_king[1])pos_stone_x = ord(pos_stone[0])pos_stone_y = int(pos_stone[1])for _ in range(int(N)): move = ctrl.index(input().rstrip()) check_king_x = pos_king_x + x[move] check_king_y = pos_king_y + y[move] if check_king_x &lt; 65 or check_king_x &gt; 72 or check_king_y &lt; 1 or check_king_y &gt; 8: continue # 여기가 문제였다! 모서리에만 집중했다 그러면 안되는데 if check_king_x == pos_stone_x and check_king_y and pos_stone_y: if (pos_stone_x==65 or pos_stone_x==72) and (pos_stone_y==1 or pos_stone_y==8): continue pos_king_x = check_king_x pos_king_y = check_king_y if pos_king_x == pos_stone_x and pos_king_y == pos_stone_y: check_stone_x = pos_stone_x + x[move] check_stone_y = pos_stone_y + y[move] if check_stone_x &lt; 65 or check_stone_x &gt; 72 or check_stone_y &lt; 1 or check_stone_y &gt; 8: continue pos_stone_x = check_stone_x pos_stone_y = check_stone_yprint(chr(pos_king_x) + str(pos_king_y), chr(pos_stone_x) + str(pos_stone_y), sep='\\n') 성공한 코드import sysinput=sys.stdin.readline# 이동 가능한 위치와 명령을 각각 x, y, ctrl 배열에 저장해둔다# 만약 'B'를 입력받으면 B는 index 2에 있으므로 x, y배열에서 index 2에 해당하는# x=0, y=-1이 수행되어 아래로 이동하게 된다x = [1, -1, 0, 0, 1, -1, 1, -1]y = [0, 0, -1, 1, 1, 1, -1, -1]ctrl = ['R', 'L', 'B', 'T', 'RT', 'LT', 'RB', 'LB']pos_king, pos_stone, N = map(str, input().split())# 편리한 계산을 위해 입력받은 알파벳을 아스키코드를 이용해 숫자로 변환한다pos_king_x = ord(pos_king[0])pos_king_y = int(pos_king[1])pos_stone_x = ord(pos_stone[0])pos_stone_y = int(pos_stone[1])for _ in range(int(N)): # 입력받은 명령의 index를 가져옴 move = ctrl.index(input().rstrip()) # 이동 가능한 위치인지 검사하기 위해 킹의 이동을 새로운 변수에 저장한다 check_king_x = pos_king_x + x[move] check_king_y = pos_king_y + y[move] # 킹이 체스판 범위를 넘어서는 경우인지 검사 if check_king_x &lt; 65 or check_king_x &gt; 72 or check_king_y &lt; 1 or check_king_y &gt; 8: continue # 이동 가능한 범위였다면 실제 킹의 위치를 이동한 위치로 변경한다 pos_king_x = check_king_x pos_king_y = check_king_y # 킹이랑 돌이 같은 위치에 서게 되는 경우 if pos_king_x == pos_stone_x and pos_king_y == pos_stone_y: # 돌도 마찬가지로 이동 가능한 위치인지 검사하기 위해 돌의 이동을 새로운 변수에 저장한다 check_stone_x = pos_stone_x + x[move] check_stone_y = pos_stone_y + y[move] # 돌이 체스판 범위를 벗어나는 경우(이동 불가능) if check_stone_x &lt; 65 or check_stone_x &gt; 72 or check_stone_y &lt; 1 or check_stone_y &gt; 8: # 킹을 이전 위치로 돌려놈 (여기가 추가한 부분) # 즉, 이동했던 방향의 반대로 다시 이동시킨다 pos_king_x -= x[move] pos_king_y -= y[move] continue # 이동 가능한 범위였다면 실제 돌의 위치를 이동한 위치로 변경한다 pos_stone_x = check_stone_x pos_stone_y = check_stone_y# 최종적인 킹과 돌의 위치를 출력한다print(chr(pos_king_x) + str(pos_king_y), chr(pos_stone_x) + str(pos_stone_y), sep='\\n')정리하자면, 내가 헤맸던 곳은 돌이 체스판의 끝에 도달해 더 이상 움직일 수 없는 상태가 되었을 때, 다음 명령에서 킹이 움직일 수 없는 상태가 된 돌이 있는 자리로 이동하려고 하면 돌은 더는 이동할 수 없으므로 해당 명령은 수행될 수 없기 때문에 이것을 어떻게 처리해야하냐는 부분이였는데, 그냥 쉽게 생각해 다시 킹을 이전 위치로 되돌려 놓으면 되는 문제였다.느낀점아직 내 수준에서 한번 쓱 읽고 만만하게 봤던 문제였던것 같다. 특히 왠지 모르겠지만 돌이 체스판의 모서리인 A1, A8, H1, H8에 있으면서 킹이 그 옆에 딱 붙어있는 경우에만 돌도 킹도 모두 막혀서 이동할 수 없다는 생각에 틀어박혀 있던것이 이 문제에 시간을 쏟은 제일 큰 오류였다. 왜 모서리에만 그렇게 집착했을까? 돌이 A7에 있고 킹이 B7에 있는 경우에 ‘L’ 명령을 받아도 둘 다 막혀서 이동할 수 없고 돌이 F1에 있고 킹이 E2에 있는 경우에 ‘RB’ 명령을 받아도 둘 다 막혀서 이동할 수 없다는 것을 뒤늦게 깨달았다. (^-^)모서리에만 집착하면서 이런 이상한 코드를 추가했는데 if check_king_x == pos_stone_x and check_king_y and pos_stone_y: if (pos_stone_x==65 or pos_stone_x==72) and (pos_stone_y==1 or pos_stone_y==8): continue이렇게 모서리에만 집착했던 이유가 코드를 완성했다고 생각하고 테스트 케이스를 넣었을 때 틀렸던 케이스가 모두 돌이 모서리에 있는 경우였기 때문인것 같다. 다음부터는 주어진 케이스에만 집중해서 코드를 구현하려고 하지 말고, 더욱 넓게 보는 습관을 길러야겠다." }, { "title": "졸업선물", "url": "/posts/%EC%A1%B8%EC%97%85%EC%84%A0%EB%AC%BC/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-30 18:39:00 +0900", "snippet": "문제선생님은 올해 졸업하는 반 학생들에게 졸업선물을 주려고 합니다.학생들에게 인터넷 쇼핑몰에서 각자 원하는 상품을 골라 그 상품의 가격과 배송비를 제출하라고 했습니다. 선생님이 가지고 있는 예산은 한정되어 있습니다. 현재 예산으로 최대 몇 명의 학생에게 선물을 사줄 수 있는지 구하는 프로그램을 작성하세요.선생님은 상품 하나를 50% 할인해서(반 가격) 살 수 있는 쿠폰을 가지고 있습니다. 배송비는 할인에 포함되지 않습니다.▣ 입력설명첫 번째 줄에 반 학생수 N(1&lt;=N&lt;=1000)과 예산 M(1&lt;=M&lt;=100,000,000)이 주어진다. 두 번째 줄부터 N줄에 걸쳐 각 학생들이 받고 싶은 상품의 가격과 배송비가 입력됩니다. 상품가격과 배송비는 각각 100,000을 넘지 않습니다. 상품가격은 짝수로만 입력됩니다.▣ 출력설명첫 번째 줄에 선생님이 현재 예산으로 선물할 수 있는 최대 학생수를 출력합니다. 선생님은 최소한 1개 이상의 상품을 살 수 있는 예산을 가지고 있습니다.▣ 입력예제 15 286 62 24 34 510 3▣ 출력예제 14▣ 출력설명(2, 2), (4, 3), (4, 5)와 (10, 3)를 할인받아 (5, 3)에 사면 비용이 4+7+9+8=28입니다.풀이핵심: 어떤 상품을 할인 받는것이 제일 좋은 선택일까에 대한 고민! 제일 비싼 상품을 할인 받는것이 최적의 선택은 아닐 수도 있음.어떤 것을 선택해야할지 기준이 애매모호함 -&gt; 완전 탐색 사용즉, 첫번째 상품을 먼저 할인해서 샀다고 생각하고 쭉 계산해보고, 그 다음으로는 두번째 상품을 할인해서 샀다고 생각하고 계산해보고, 그 다음은 세번째 네번째….를 반복해서 목표에 부합하는 가장 최적의 값을 구하면 된다.function solution(M, product) { let answer = 0; product.sort((a, b) =&gt; a[0] + a[1] - (b[0] + b[1])); console.log(product); for (let i = 0; i &lt; product.length; i++) { // 상품가격은 짝수로만 입력된다는 조건이 있으므로 Math.floor 같은거 필요 X // 처음 상품부터 하나씩 쭉 할인해서 사보고 money에 미리 저장 let money = M - (product[i][0] / 2 + product[i][1]); let cnt = 1; for (let j = 0; j &lt; product.length; j++) { // 이전에 할인해서 산 상품과 동일한 상품이 아니면서 // 남은 예산보다 적은 비용이 드는 상품이여야 구매가 가능하므로 조건 걸어주기 if (j !== i &amp;&amp; product[j][0] + product[j][1] &lt;= money) { money -= product[j][0] + product[j][1]; cnt += 1; } else { // 조건을 벗어나서 헛돌며 시간 사용하는것을 방지 break; } } answer = Math.max(answer, cnt); } return answer;}let product = [ [6, 6], [2, 2], [4, 3], [4, 5], [10, 3],];console.log(solution(28, product));" }, { "title": "멘토링", "url": "/posts/%EB%A9%98%ED%86%A0%EB%A7%81/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-28 23:11:00 +0900", "snippet": "문제현수네 반 선생님은 반 학생들의 수학점수를 향상시키기 위해 멘토링 시스템을 만들려고 합니다. 멘토링은 멘토(도와주는 학생)와 멘티(도움을 받는 학생)가 한 짝이 되어 멘토가 멘티의 수학공부를 도와주는 것입니다. 선생님은 M번의 수학테스트 등수를 가지고 멘토와 멘티를 정합니다. 만약 A학생이 멘토이고, B학생이 멘티가 되는 짝이 되었다면, A학생은 M번의 수학테스트에서 모두 B학생보다 등수가 앞서야 합니다. M번의 수학성적이 주어지면 멘토와 멘티가 되는 짝을 만들 수 있는 경우가 총 몇 가지 인지 출력하는 프로그램을 작성하세요.▣ 입력설명첫 번째 줄에 반 학생 수 N(1&lt;=N&lt;=20)과 M(1&lt;=M&lt;=10)이 주어진다.두 번째 줄부터 M개의 줄에 걸쳐 수학테스트 결과가 학생번호로 주어진다.학생번호가 제일 앞에서부터 1등, 2등, …N등 순으로 표현된다. 만약 한 줄에 N=4이고, 테스트 결과가 3 4 1 2로 입력되었다면 3번 학생이 1등, 4번 학생이 2등, 1번 학생이 3등, 2번 학생이 4등을 의미합니다.▣ 출력설명첫 번째 줄에 짝을 만들 수 있는 총 경우를 출력합니다.▣ 입력예제 14 33 4 1 24 3 2 13 1 4 2▣ 출력예제 13(3, 1), (3, 2), (4, 2)와 같이 3가지 경우의 (멘토, 멘티) 짝을 만들 수 있다.풀이function solution(N, M, arr) { let answer = 0; // i:멘토, j:멘티라고 했을 때 학생이 4명이면 (1,1)(1,2)..(4,4)로 모든 // 경우의 수를 for 문 2개(i와 j)로 모두 탐색 가능 for (let i = 1; i &lt;= N; i++) { for (let j = 1; j &lt;= N; j++) { let cnt = 0; for (let k = 0; k &lt; M; k++) { // pi: i번 학생의 등수 let pi = (pj = 0); for (let s = 0; s &lt; N; s++) { // 배열에서 해당 위치의 원소와 학생 번호인 i가 같다면 해당 학생의 위치인 s를 // i번 학생의 등수를 의미하는 pi 변수에 저장한다. if (arr[k][s] === i) pi = s; // 마찬가지로 멘티를 의미하는 j도 i와 같이 검사해 해당 등수를 pj에 저장한다. if (arr[k][s] === j) pj = s; } // pi와 pj를 비교해 멘토를 의미하는 pi의 숫자가 더 작다면(왜나면 등수가 높다는건 숫자가 작다는 것이므로) // cnt를 하나 증가시킨다 if (pi &lt; pj) cnt += 1; } // 만약 최종 cnt 개수가 테스트 수인 M과 같다면 모든 테스트를 통과한 조합이므로 // 얘네는 팀이 될 수 있다. 따라서 최종 결과인 answer를 증가시킨다 if (cnt === M) answer += 1; } } return answer;}let N = 4;let M = 3;let arr = [ [3, 4, 1, 2], [4, 3, 2, 1], [3, 1, 4, 2],];console.log(solution(N, M, arr));" }, { "title": "뒤집은 소수", "url": "/posts/%EB%92%A4%EC%A7%91%EC%9D%80%EC%86%8C%EC%88%98/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-24 23:17:00 +0900", "snippet": "문제N개의 자연수가 입력되면 각 자연수를 뒤집은 후 그 뒤집은 수가 소수이면 그 소수를 출력하는 프로그램을 작성하세요. 예를 들어 32를 뒤집으면 23이고, 23은 소수이다. 그러면 23을 출력한다. 단 910를 뒤집으면 19로 숫자화 해야 한다. 첫 자리부터의 연속된 0은 무시한다.▣ 입력설명첫 줄에 자연수의 개수 N(3&lt;=N&lt;=100)이 주어지고, 그 다음 줄에 N개의 자연수가 주어진다. 각 자연수의 크기는 100,000를 넘지 않는다.▣ 출력설명첫 줄에 뒤집은 소수를 출력합니다. 출력순서는 입력된 순서대로 출력합니다.▣ 입력예제 1932 55 62 20 250 370 200 30 100▣ 출력예제 123 2 73 2 3풀이/* 소수 판별하는 함수 */const isPrime = (n) =&gt; { // 1은 소수 아니니까 예외처리 if (n === 1) { return false; } for (let i = 2; i &lt;= Math.floor(Math.sqrt(n)); i++) { if (n % i === 0) { // 한 번이라도 나누어 졌으니 소수가 아님ㄴ return false; } } // 나눠진 수가 없다면 해당 수는 소수 return true;};/* 메인 함수 */function solution(arr) { let answer = []; for (num of arr) { // 입력받은 숫자 뒤집기 num = Number(num.toString().split(\"\").reverse().join(\"\")); // 소수 판별 함수 실행 if (isPrime(num)) { answer.push(num); } } return answer;}let arr = [32, 55, 62, 20, 250, 370, 200, 30, 100];console.log(solution(arr)); // [23, 2, 73, 2, 3]알게된 점에라토스테네스의 체에라토스테네스의 체는 쉽게 말하면 어떤 수의 소수의 여부를 확인 할 때는, 특정한 숫자의 제곱근 까지만 약수의 여부를 검증하는 것으로, O(N^1/2)의 시간 복잡도로 빠르게 구할 수 있는 알고리즘이다.(과정) 범위에서 합성수를 지우는 방식으로 소수를 찾는 방법. 1 제거 지워지지 않은 수 중 제일 작은 2를 소수로 채택하고, 나머지 2의 배수를 모두 지운다. 지워지지 않은 수 중 제일 작은 3을 소수로 채택하고, 나머지 3의 배수를 모두 지운다. 지워지지 않은 수 중 제일 작은 5를 소수로 채택하고, 나머지 5의 배수를 모두 지운다. (위 과정을 반복한다)" }, { "title": "자릿수의 합", "url": "/posts/%EC%9E%90%EB%A6%BF%EC%88%98%EC%9D%98%ED%95%A9/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-23 15:47:00 +0900", "snippet": "문제N개의 자연수가 입력되면 각 자연수의 자릿수의 합을 구하고, 그 합이 최대인 자연수를 출력하는 프로그램을 작성하세요. 자릿수의 합이 같은 경우 원래 숫자가 큰 숫자를 답으로 합니다. 만약 235 와 1234가 동시에 답이 될 수 있다면 1234를 답으로 출력해야 합니다.▣ 입력설명첫 줄에 자연수의 개수 N(3&lt;=N&lt;=100)이 주어지고, 그 다음 줄에 N개의 자연수가 주어진다. 각 자연수의 크기는 10,000,000를 넘지 않는다.▣ 출력설명자릿수의 합이 최대인 자연수를 출력한다.▣ 입력예제 17128 460 603 40 521 137 123▣ 출력예제 1137풀이function solution(arr) { let answer = []; let maxNum = Number.MIN_SAFE_INTEGER; for (num of arr) { let sum = 0; let tmp = num; do { sum += tmp % 10; tmp = Math.floor(tmp / 10); } while (tmp &gt; 0); if (sum &gt; maxNum) { maxNum = sum; answer = num; } else if (sum === maxNum) { if (answer &lt; num) { answer = num; } } } return answer;}let arr = [128, 460, 603, 40, 521, 137, 123];console.log(solution(arr));내장함수로 자릿수 계산 하는법function solution(arr) { let answer = []; let maxNum = Number.MIN_SAFE_INTEGER; for (num of arr) { // 내장함수로 한번에 자릿수 계산하는법 let sum = num .toString() .split(\"\") .reduce((a, b) =&gt; a + Number(b), 0); if (sum &gt; maxNum) { maxNum = sum; answer = num; } else if (sum === maxNum) { if (answer &lt; num) { answer = num; } } } return answer;}let arr = [128, 460, 603, 40, 521, 137, 123];console.log(solution(arr));" }, { "title": "문자열 압축", "url": "/posts/%EB%AC%B8%EC%9E%90%EC%97%B4%EC%95%95%EC%B6%95/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-22 17:30:00 +0900", "snippet": "문제알파벳 대문자로 이루어진 문자열을 입력받아 같은 문자가 연속으로 반복되는 경우 반복되는 문자 바로 오른쪽에 반복 횟수를 표기하는 방법으로 문자열을 압축하는 프로그램을 작성하시오. 단 반복횟수가 1인 경우 생략합니다.▣ 입력설명첫 줄에 문자열이 주어진다. 문자열의 길이는 100을 넘지 않는다.▣ 출력설명첫 줄에 압축된 문자열을 출력한다.▣ 입력예제 1KKHSSSSSSSE▣ 출력예제 1K2HS7E틀린 풀이(첫 시도)function solution(str) { let answer = \"\"; // 데이터 가공 str = str.split(\"\"); let setStr = new Set(str); // map 생성 let zip = new Map(); // 이전에 중복을 제거해둔 데이터에서 각 알파벳을 하나씩 꺼내와 // 기존 문자열에 해당 알파벳이 몇개 있는지 세어 cnt에 저장 for (i of setStr) { let cnt = 0; for (j of str) { if (i === j) { cnt += 1; } } // 세어진 알파벳 개수를 생성한 map에 key, value로 저장 zip.set(i, cnt); } // map을 돌며 각 key, value값을 검사해 for (let [key, value] of zip) { // value가 1이면 key만 answer에 추가 if (value === 1) { answer += key; } // value가 1이 아니면 key와 value모두 answer에 추가 else { answer += key + value; } } return answer;}let str = \"KKHSSSSSSSE\";console.log(solution(str)); // K2HS7E근데 이렇게 하면 하나의 알파벳을 검사할 때마다 전체 문자열을 싹 다 돌아야되므로 시간도 오래 걸리고, 만약 KKHKKSSSSSSE라는 문자열이 입력으로 주어지는 경우 K2HK2S6E가 출력되어야 하는데 문자열 전체에 해당 알파벳이 몇개 있나 검사하게 되므로 K4HS6E가 출력된다. 고로 이 풀이는 열심히 생각했지만, 정답이 아니다.올바른 풀이function solution(str) { let answer = \"\"; let cnt = 1; // 마지막 문자도 출력되어야 하므로 문자열 마지막에 \" \"를 임의로 만들어줌 str = str + \" \"; for (i = 0; i &lt; str.length - 1; i++) { if (str[i] === str[i + 1]) { cnt += 1; } else { answer += str[i]; if (cnt &gt; 1) { answer += String(cnt); cnt = 1; } } } return answer;}let str = \"KKHSSSSSSSE\";console.log(solution(str)); // K2HS7E이 경우에는 KKHKKSSSSSSE라는 문자열이 입력으로 주어지는 경우에도 K2HK2S6E로 올바르게 출력된다." }, { "title": "가장 짧은 문자 거리", "url": "/posts/%EA%B0%80%EC%9E%A5%EC%A7%A7%EC%9D%80%EB%AC%B8%EC%9E%90%EA%B1%B0%EB%A6%AC/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-21 15:22:00 +0900", "snippet": "문제한 개의 문자열 s와 문자 t가 주어지면 문자열 s의 각 문자가 문자 t와 떨어진 최소거리를 출력하는 프로그램을 작성하세요.▣ 입력설명첫 번째 줄에 문자열 s와 문자 t가 주어진다. 문자열과 문자는 소문자로만 주어집니다. 문자열의 길이는 100을 넘지 않는다.▣ 출력설명첫 번째 줄에 각 문자열 s의 각 문자가 문자 t와 떨어진 거리를 순서대로 출력한다.▣ 입력예제 1teachermode e▣ 출력예제 11 0 1 2 1 0 1 2 2 1 0풀이function solution(s, t) { let answer = []; // 입력받은 s 안에 들어있는 e의 index 위치를 저장해둘 배열 let index = []; // split한 매 문자부터 각각의 e까지의 거리를 담을 배열 let check = []; s = s.split(\"\"); // indexOf를 이용해 처음 나오는 e의 index를 idx에 저장함(여기서는 idx=1이 됨) let idx = s.indexOf(t); // idx(입력받은 t변수)의 값이 더이상 존재하지 않을 때까지 반복하라는 의미 while (idx != -1) { index.push(idx); // indexOf()의 fromIndex 인자 부분에 idx+1을 해서 확인된 // e위치(1)의 다음 위치부터 다른 e의 index값을 다시 탐색하게함 idx = s.indexOf(t, idx + 1); } // 입력받은 문자열 s를 split()한 배열과 입력받은 문자인 // t(==e)의 index위치를 저장한 index 배열을 순회함 for (i = 0; i &lt; s.length; i++) { for (x of index) { // 배열 s의 요소와 문자 e까지의 거리를 각각 계산해 뺄셈을 통해 계산해 check 배열에 입력해둠 if (x - i &gt; 0) { check.push(x - i); } else { check.push(i - x); } } // 문자열 s의 문자를 하나씩 돌 때마다 check 배열에 들어가있는 거리 값을 확인해 // 최소값을 실제 반환할 배열인 answer에 집어넣은 후 answer.push(Math.min(...check)); // 다음 문자와 e의 거리를 구하기 위해 check 배열을 초기화 check = []; } return answer;}let s = \"teachermode\";let t = \"e\";console.log(solution(s, t));// [1, 0, 1, 2, 1, 0, 1, 2, 2, 1, 0]알게 된 점 str.indexOf(searchValue[, fromIndex])indexOf()의 fromIndex 매개변수 사용법searchValue찾으려는 문자(열)을 입력하는 부분. 아무 값도 주어지지 않으면 문자열 “undefined”를 찾으려는 문자열로 사용.fromIndex (Optional)문자열에서 찾기 시작하는 위치를 나타내는 인덱스 값. 어떤 정수값이라도 가능. 기본값은 0이며, 이때는 문자열 전체를 대상으로 찾게됨. 만약 fromIndex 값이 음의 정수여도 전체 문자열을 찾게 됨. 만약 fromIndex &gt;= str.length가 되면, 검색하지 않고 바로 -1을 반환함. searchValue가 공백 문자열이 아니라면, str.length를 반환함.즉, 0 &lt; fromIndex &lt; stringValue.length-1 이 정상 작동 범위반환 값searchValue의 첫 번째 등장 인덱스. 찾을 수 없으면 -1.그리고 저번에도 했었는데, 배열에서 최소, 최대값 뽑아내려면 스프레드 연산자 사용하자." }, { "title": "숫자만 추출하기", "url": "/posts/%EC%88%AB%EC%9E%90%EB%A7%8C-%EC%B6%94%EC%B6%9C/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-17 21:45:00 +0900", "snippet": "문제문자와 숫자가 섞여있는 문자열이 주어지면 그 중 숫자만 추출하여 그 순서대로 자연수를 만듭니다. 만약 “tge0a1h205er”에서 숫자만 추출하면 0, 1, 2, 0, 5이고 이것을 자연수를 만들면 1205 이 됩니다. 추출하여 만들어지는 자연수는 100,000,000을 넘지 않습니다.▣ 입력설명첫 줄에 숫자가 썩인 문자열이 주어집니다. 문자열의 길이는 50을 넘지 않습니다.▣ 출력설명첫 줄에 자연수를 출력합니다.▣ 입력예제 1g0en2T0s8eSoft▣ 출력예제 1208풀이정규식 사용한 풀이function solution(input) { let answer = \"\"; // 정규식(/[^0-9]/g, ''): 숫자가 아닌 것들을 모두 찾아 ''로 바꾼다. answer = input.replace(/[^0-9]/g, \"\"); return Number(answer);}let input = \"g0en2T0s8eSoft\";console.log(solution(input));숫자인지 하나씩 확인하는 풀이function solution(input) { let answer = \"\"; for (let word of input) { if (!isNaN(word)) { answer += word; } } return Number(answer);}let input = \"g0en2T0s8eSoft\";console.log(solution(input));isNaN() 은 숫자인 값을 찾는 메서드가 아닌 숫자가 아닌 값을 찾는 메서드이다. 따라서 들어오는 값이 숫자라면 false를, 숫자면 true를 반환하므로 위의 코드에서 앞에 !를 붙여준 것이다.그런데 주의할 점이 isNaN()은 입력받은 값이 Number 형이 아닌 경우 해당 값을 먼저 숫자로 형 변환한 후 NaN인지 판별하기 때문에, isNaN(‘456’)을 입력해도 숫자로 인식하고 false를 반환하며 isNaN(‘‘)과 같이 빈 값을 입력해도 0으로 인식해 false를 반환하게 된다. 또한, isNaN(true), isNaN(false)와 같은 경우도 결국 1과 0을 나타내므로 false를 반환하기 때문에 예상치 못한 결과를 낼 수도 있음에 주의해야 한다.위와 같은 주의점으로 인해 Number.isNaN()을 사용하는 것이 더욱 엄격한 방법이 될 수 있다. 이는 입력받은 값을 강제로 숫자로 형 변환하지 않고, 주어진 값이 Number 형이고, 값이 NaN이면 true를 아니면 false 반환한다." }, { "title": "유효한 팰린드롬", "url": "/posts/%EC%9C%A0%ED%9A%A8%ED%95%9C-%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-15 21:47:00 +0900", "snippet": "문제앞에서 읽을 때나 뒤에서 읽을 때나 같은 문자열을 팰린드롬이라고 합니다. 문자열이 입력되면 해당 문자열이 팰린드롬이면 “YES”, 아니면 “NO”를 출력하는 프로그램을 작성하세요. 단, 회문을 검사할 때 알파벳만 가지고 회문을 검사하며, 대소문자를 구분하지 않습니다. 알파벳 이외의 문자들은 무시합니다.▣ 입력설명첫 줄에 정수 길이 100을 넘지 않는 공백이 없는 문자열이 주어집니다.▣ 출력설명첫 번째 줄에 팰린드롬인지의 결과를 YES 또는 NO로 출력합니다.▣ 입력예제 1found7, time: study; Yduts; emit, 7Dnuof▣ 출력예제 1YES풀이function solution(input) { let answer = \"\"; // 정규식(/[^a-z]/g, ''): 소문자가 아닌 것들을 모두 찾아 ''로 바꾼다. input = input.toLowerCase().replace(/[^a-z]/g, \"\"); let reversedInput = input.split(\"\").reverse().join(\"\"); if (input === reversedInput) { answer = \"YES\"; } else { answer = \"NO\"; } return answer;}let input = \"found7, time: study; Yduts; emit, 7Dnuof\";console.log(solution(input));이전에 풀었던 회문 문자열 문제와 동일한 로직을 사용하는 대신 이번에는 문자열에서 소문자를 제외한 다른 문자들(숫자, 특수기호 등)은 제거해야하므로 정규식을 사용했다." }, { "title": "회문 문자열", "url": "/posts/%ED%9A%8C%EB%AC%B8%EB%AC%B8%EC%9E%90%EC%97%B4/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-14 00:50:00 +0900", "snippet": "문제앞에서 읽을 때나 뒤에서 읽을 때나 같은 문자열을 회문 문자열이라고 합니다.문자열이 입력되면 해당 문자열이 회문 문자열이면 “YES”, 회문 문자열이 아니면 “NO”를 출력 하는 프로그램을 작성하세요.단, 회문을 검사할 때 대소문자를 구분하지 않습니다.▣ 입력설명첫 줄에 정수 길이 100을 넘지 않는 공백이 없는 문자열이 주어집니다.▣ 출력설명첫 번째 줄에 회문 문자열인지의 결과를 YES 또는 NO로 출력합니다.▣ 입력예제 1gooG▣ 출력예제 1YES풀이첫번째 방법첫번째 방법은 입력받은 문자열의 첫번째 값과 맨 끝에 있는 값, 두번째에 있는 값과 맨 끝에서 두번째에 있는 값을 비교하는 것으로 문자열의 길이가 n이라면 인덱스 0과 n을, 1과 n-1을, 2와 n-2를 점점 비교해 나가는 방식이다. 회문이 아니라면 중간에 다른 값이 들어있을 것이므로 그때 바로 NO를 반환하면 된다.function solution(input) { input = input.toLowerCase(); for (let i = 0; i &lt; Math.floor(input.length / 2); i++) { if (input[i] !== input[input.length - i - 1]) { return \"NO\"; } } return \"YES\";}let input = \"gooG\";console.log(solution(input)); // YES두번째 방법자바스크립트에는 문자열을 바로 뒤집는 내장 함수가 존재하지 않고, 배열을 뒤집는 함수만 존재하므로 아래와 같은 방법을 사용한다.두번째 방법에서는 split(), reverse(), join()이 핵심으로 이 3가지 메서드를 써서 먼저 입력받은 문자열을 split()을 이용해 배열로 만든 뒤 reverse()를 이용해 뒤집고 뒤집어진 배열의 요소를 다시 join()으로 합쳐서 결론적으로는 뒤집어진 문자열을 만들어내는 방법이다.function solution(input) { let answer = \"\"; input = input.toLowerCase(); // 입력받은 문자열을 배열로 만들어 뒤집어 다시 join으로 합치기 const reversedInput = input.split(\"\").reverse().join(\"\"); if (input === reversedInput) { answer = \"YES\"; } else { answer = \"NO\"; } return answer;}let input = \"gooG\";console.log(solution(input)); // YES" }, { "title": "봉우리", "url": "/posts/%EB%B4%89%EC%9A%B0%EB%A6%AC/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-13 21:27:00 +0900", "snippet": "문제지도 정보가 N x N 격자판에 주어집니다. 각 격자에는 그 지역의 높이가 쓰여있습니다. 각 격자 판의 숫자 중 자신의 상하좌우 숫자보다 큰 숫자는 봉우리 지역입니다. 봉우리 지역이 몇 개 있는지 알아내는 프로그램을 작성하세요.격자의 가장자리는 0으로 초기화 되었다고 가정한다.만약 N=5 이고, 격자판의 숫자가 다음과 같다면 봉우리의 개수는 10개입니다.▣ 입력설명첫 줄에 자연수 N이 주어진다.(1&lt;=N&lt;=50)두 번째 줄부터 N줄에 걸쳐 각 줄에 N개의 자연수가 주어진다.각 자연수는 100을 넘지 않는다.▣ 출력설명봉우리의 개수를 출력하세요.▣ 입력예제 155 3 7 2 33 7 1 6 17 2 5 3 44 3 6 4 18 7 3 5 2▣ 출력예제 110풀이function solution(N, arr) { let answer = 0; // 상하좌우의 4가지 방향 지정 const dx = [-1, 1, 0, 0]; const dy = [0, 0, -1, 1]; // 입력으로 받은 arr 배열의 (0,0)~(끝,끝)까지 순차적 탐색 for (let x = 0; x &lt; N; x++) { for (let y = 0; y &lt; N; y++) { // 자신을 기준으로 상하좌우 숫자들이 모두 자신보다 작아야 // 봉우리라고 할 수 있으므로 이를 판단할 부울 변수를 지정 let notHighest = false; // 상하좌우 4가지 방향을 확인해야 하므로 한번 더 for문 for (let k = 0; k &lt; 4; k++) { // nx, ny가 자신을 기준으로 상하좌우가 됨 let nx = x + dx[k]; let ny = y + dy[k]; // 범위를 벗어나는 곳(ex. (0,0), (0,1)과 같이 // 벽에 붙어있어 특정 구간 탐색 시 범위를 벗어나는 좌표들을 제외 if (0 &lt;= nx &amp;&amp; nx &lt; N &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; N) { // 자신의 상하좌우 값과 비교해 가장 높은 수를 가지지 않았다면 if (arr[nx][ny] &gt;= arr[x][y]) { notHighest = true; break; } } } // notHighest가 false 라는것은 가장 높은 숫자를 가진 // 봉우리라는 의미이므로 answer을 하나 증가시킴 if (notHighest === false) { answer += 1; } } } return answer;}let N = 5;let arr = [ [5, 3, 7, 2, 3], [3, 7, 1, 6, 1], [7, 2, 5, 3, 4], [4, 3, 6, 4, 1], [8, 7, 3, 5, 2],];console.log(solution(N, arr)); // 10" }, { "title": "JS ES6 - var, let, const", "url": "/posts/JS-var-let-const/", "categories": "Javascript ES6", "tags": "", "date": "2022-07-12 19:51:00 +0900", "snippet": "var, let, const 특징 한 눈에 보기 종류 재선언 재할당 범위 var O O 함수 let X O 블록 const X X 블록 var의 사용을 지양하는 이유 같은 이름을 가진 변수의 중복 생성(재선언)이 가능하므로 예상하지 못한 값을 반환할 수 있다. (협업에도 방해될듯) 정의된 변수가 함수 레벨의 스코프를 가진다. 따라서 함수 외부에서 선언한 변수는 모두 전역 변수가 되어 외부에서도 참조가 가능하다. var 키워드를 생략하고 값을 할당하면 암묵적 전역 변수를 양산할 가능성이 있다. 변수 호이스팅에 의해 변수를 선언하기 전에도 참조할 수 있으며 undefined로 초기화 된다.이처럼 var를 사용하는 것을 지양하는 가장 큰 이유는 전역 변수로 인한 문제 때문인데, 이는 유효 범위가 넓어 어디에서 어떤식으로 사용되는 변수들인지 파악하는 것이 힘들다. 또한 var를 사용한 변수는 재선언이 가능하므로 의도치 않게 값이 변경될 수도 있기 때문에 버그가 발생할 위험이 높고, 복잡성도 증가된다.그래서 나온 let, const(해결 1) 변수 중복 선언 불가let과 const는 모두 변수의 재선언이 불가하지만, let은 “재할당”은 가능하다. const는 재할당도 불가능하다.또한, const는 반드시 선언과 초기화를 동시에 진행해야 한다.다만, 주의할 점은 “완전한 불변”을 의미하지는 않는다. 따라서const Obj = { name: \"Lee\" };Obj.name = \"Park\";const로 선언한 객체여도 이와 같은 오브젝트 내의 프로퍼티 변경은 가능하다. 이것을 완전 불변으로 만들고 싶다면 Object.freeze(객체명)를 사용해야 한다.(해결 2) 블록 레벨 스코프를 가지도록 함let, const로 선언한 변수는 블록 레벨 스코프(함수, if, for, while, try/catch)를 따른다.따라서 아래와 같은 경우의 예시를 보면var를 사용했을 때var a = 1;if (true) { var a = 2;}console.log(a); // 2let을 사용했을 때let a = 1;if (true) { let a = 2;}console.log(a); // 1var을 사용했을 때는 함수 레벨 스코프이기 때문에 if문 안에 선언한 변수에 의해 값이 변경되어 출력되는데, let을 사용한 경우 블록 레벨 스코프이기 때문에 let a = 2는 if문 안에서만 유효하므로 외부에서 a를 출력해보면 전역으로 선언 된 1이 출력된다.(const도 동일하다.)이렇게 해서 전역 변수의 암묵적 양산과 같은 행동을 방지할 수 있다.(해결 3) 변수 호이스팅 문제 해결일단 호이스팅이란, 자바스크립트 엔진이 변수 및 함수의 메모리 공간을 선언 전에 미리 할당하는 작업을 의미한다. 다르게 말하면 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것처럼 행동한다고 할 수 있다.(var, let, const 뿐 아니라 function, class 키워드를 사용해 선언한 식별자들도 호이스팅 대상에 해당한다.)자바스크립트에서 변수 선언은 선언 단계, 초기화 단계 그리고 할당 단계를 거쳐 수행된다. 선언 단계는 변수를 등록해 자바스크립트 엔진에 변수가 있다는 것을 알려주는 역할이다. 초기화 단계는 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해두는 작업을 하는 역할이다. 할당 단계는 사용자가 초기화된 메모리에 다른 값을 할당하는 단계이다.var단계 1) 선언 + 초기화단계 2) 할당단계 1에서 선언 단계와 초기화 단계가 동시에 진행되었으므로 var로 선언한 이후 값을 초기화하지 않고 console.log()로 출력해보면 undefined가 출력된다.let단계 1) 선언단계 2) 일시적 사각지대단계 3) 초기화단계 4) 할당 일시적 사각지대(Temporal Dead Zone: TDZ): 스코프의 시작 지점부터 초기화 단계의 시작 지점까지는 변수를 참조할 수 없는 상태let으로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행된다. 따라서 초기화 단계 이전에 호출하면 Reference Error가 발생한다.let age = 5;{ console.log(age); // Reference Error let age = 25;}let은 블록 레벨 스코프를 가지고 있기 때문에 위의 코드와 같은 경우에도 참조 에러를 뱉어낸다.constconst로 선언한 변수는 선언 단계와 초기화 단계가 동시에 진행된다. 따라서 선언 및 초기화 이전에 해당 변수를 호출하게 되면 Reference Error가 발생한다.정리 ES6 이상부터는 var를 사용하지 말자. 대부분의 변수에는 const를 활용하며, let은 재할당이 필요한 경우에 한정에 사용하는 습관을 들이자." }, { "title": "격자판 최대합", "url": "/posts/%EA%B2%A9%EC%9E%90%ED%8C%90-%EC%B5%9C%EB%8C%80%ED%95%A9/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-11 18:30:00 +0900", "snippet": "문제5*5 격자판에 아래롸 같이 숫자가 적혀있습니다.N*N의 격자판이 주어지면 각 행의 합, 각 열의 합, 두 대각선의 합 중 가 장 큰 합을 출력합니다.▣ 입력설명첫 줄에 자연수 N이 주어진다.(1&lt;=N&lt;=50)두 번째 줄부터 N줄에 걸쳐 각 줄에 N개의 자연수가 주어진다. 각 자연수는 100을 넘지 않는다.▣ 출력설명최대합을 출력합니다.▣ 입력예제 1510 13 10 12 1512 39 30 23 1111 25 50 53 1519 27 29 37 2719 13 30 13 19▣ 출력예제 1155풀이1. 처음에 작성한 풀이function solution(bingo) { let answer = []; let vertical = new Array(bingo.length).fill(0).map(() =&gt; new Array()); let diagonal = new Array(2).fill(0).map(() =&gt; new Array()); // 기존 빙고판에서 열 분리 for (i = 0; i &lt; bingo.length; i++) { for (j = 0; j &lt; bingo.length; j++) { vertical[i].push(bingo[j][i]); } } // 기존 빙고판에서 대각선 분리 for (i = 0; i &lt; bingo.length; i++) { diagonal[0].push(bingo[i][i]); diagonal[1].push(bingo[i][bingo.length - i - 1]); } // 행 합 push for (i = 0; i &lt; bingo.length; i++) { answer.push(bingo[i].reduce((acc, curr) =&gt; acc + curr, 0)); } // 열 합 push for (i = 0; i &lt; vertical.length; i++) { answer.push(vertical[i].reduce((acc, curr) =&gt; acc + curr, 0)); } // 대각선 합 push for (i = 0; i &lt; diagonal.length; i++) { answer.push(diagonal[i].reduce((acc, curr) =&gt; acc + curr, 0)); } return Math.max(...answer);}let bingo = [ [10, 13, 10, 12, 15], [12, 39, 30, 23, 11], [11, 25, 50, 53, 15], [19, 27, 29, 37, 27], [19, 13, 30, 13, 19],];console.log(solution(bingo)); // 155처음에 작성한 코드는 아무리 봐도 뭔가 굳이 들어가야 할까? 싶은 생각이 드는 코드가 많고 어딘가 비효율적인 느낌이 들었다.그래서 기존 빙고에서 굳이 행,열,대각선을 분리하지 않고 한번의 2중 for문으로 행,열,대각선의 합을 모두 구해 최대값을 판단하는 방법이 없을까 생각해보게 되었다.2. 최종 풀이function solution(bingo) { let answer = []; let columnSum = 0; let rowSum = 0; let diagonalSum1 = 0; let diagonalSum2 = 0; for (i = 0; i &lt; bingo.length; i++) { rowSum = columnSum = 0; for (j = 0; j &lt; bingo.length; j++) { rowSum += bingo[i][j]; // 행 합 columnSum += bingo[j][i]; // 열 합 } answer.push(rowSum, columnSum); // 대각선 합 diagonalSum1 += bingo[i][i]; diagonalSum2 += bingo[i][bingo.length - i - 1]; if (i === bingo.length - 1) { answer.push(diagonalSum1, diagonalSum2); } } return Math.max(...answer);}let bingo = [ [10, 13, 10, 12, 15], [12, 39, 30, 23, 11], [11, 25, 50, 53, 15], [19, 27, 29, 37, 27], [19, 13, 30, 13, 19],];console.log(solution(bingo)); // 155하나의 for문 안에서 각 행,열,대각선에 대한 합을 계산한 뒤 하나씩 answer 배열에 넣어 마지막에 모든 합들을 넣어둔 answer 배열 안에서의 최대값을 반환한다." }, { "title": "등수 구하기", "url": "/posts/%EB%93%B1%EC%88%98%EA%B5%AC%ED%95%98%EA%B8%B0/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-09 14:04:00 +0900", "snippet": "문제N(1&lt;=N&lt;=100)명의 학생의 국어점수가 입력되면 각 학생의 등수를 입력된 순서대로 출력하는 프로그램을 작성하세요.▣ 입력설명첫 줄에 N(3&lt;=N&lt;=1000)이 입력되고, 두 번째 줄에 국어점수를 의미하는 N개의 정수가 입력 된다.같은 점수가 입력될 경우 높은 등수로 동일 처리한다. 즉 가장 높은 점수가 92점인데 92점이 3명 존재하면 1등이 3명이고 그 다음 학생은 4등이 된다.▣ 출력설명입력된 순서대로 등수를 출력한다.▣ 입력예제 1587 89 92 100 76▣ 출력예제 14 3 2 1 5풀이function solution(scores) { let answer = []; let newScores = [...scores].sort((a, b) =&gt; b - a); for (i = 0; i &lt; scores.length; i++) { answer.push(newScores.indexOf(scores[i]) + 1); } console.log(scores, newScores); return answer;}let scores = [87, 89, 92, 100, 76];console.log(solution(scores));// [4, 3, 2, 1, 5]solution 함수의 파라미터로 받아온 scores라는 배열을 정렬한 뒤 newScores라는 배열에 저장하고, 기존의 scores 배열은 정렬되지 않은 퓨어한 상태로 놔둔다.그러면 newScores 배열에는 제일 높은 점수를 가진 사람을 인덱스 0번째로 하여 내림차순으로 정렬되어 있을 것이므로 반복문을 통해 입력받은 점수인 scores 배열의 각 요소를 하나씩 돌면서 newScores 배열에서 score에 각 요소에 해당하는 인덱스 위치를 indexOf()를 통해 찾아 answer 배열에 추가하면 된다.알게 된 점1. 자바스크립트에서 원래 배열을 변경하지 않고 정렬하는 방법let newArr = arr.sort()를 사용하면 기존의 arr 배열도 정렬된 상태로 바뀌고 newArr에도 정렬된 arr 배열이 들어가게 된다. 하지만, 나는 newArr에는 정렬된 arr 배열이 들어가도록 하는 대신, 기존의 arr 배열은 정렬되지 않은 순수한 처음의 상태로 유지되게 하고 싶었다.이러한 경우 ES6에서 사용할 수 있는 방법이 있다.let newArr = [...arr].sort()이것은 slice()를 사용해 배열을 복사해서 정렬하는 것과 같은 느낌을 준다고 생각하면 된다.2. 자바스크립트에서의 숫자 sort()가 제대로 안된다?자바스크립트에서 배열을 정렬 할 때는 기본적으로 각 요소를 문자열로 판단해 정렬을 수행하기 때문에 숫자를 정렬하는 경우 순서가 뒤죽박죽 되는 현상을 경험할 수 있다.따라서 sort()로 숫자를 비교하려면 비교하는 두 요소가 숫자로 캐스팅되도록 해야한다.sort() 메서드에 비교 함수를 인자로 넘겨 올바른 숫자 비교를 수행하도록 할 수 있다.// 오름차순arr.sort((a, b) =&gt; a - b);// 내림차순arr.sort((a, b) =&gt; b - a);" }, { "title": "점수 계산", "url": "/posts/%EC%A0%90%EC%88%98%EA%B3%84%EC%82%B0/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-08 18:37:00 +0900", "snippet": "문제OX 문제는 맞거나 틀린 두 경우의 답을 가지는 문제를 말한다. 여러 개의 OX 문제로 만들어진 시험에서 연속적으로 답을 맞히는 경우에는 가산점을 주기 위해서 다음과 같이 점수 계산을 하기로 하였다.1번 문제가 맞는 경우에는 1점으로 계산한다. 앞의 문제에 대해서는 답을 틀리다가 답이 맞는 처음 문제는 1점으로 계산한다. 또한, 연속으로 문제의 답이 맞는 경우에서 두 번째 문제는 2점, 세 번째 문제는 3점, …, K번째 문제는 K점으로 계산한다. 틀린 문제는 0점으로 계산한다.예를 들어, 아래와 같이 10 개의 OX 문제에서 답이 맞은 문제의 경우에는 1로 표시하고, 틀린 경 우에는 0으로 표시하였을 때, 점수 계산은 아래 표와 같이 계산되어, 총 점수는 1+1+2+3+1+2=10 점이다.시험문제의 채점 결과가 주어졌을 때, 총 점수를 계산하는 프로그램을 작성하시오.▣ 입력설명첫째 줄에 문제의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에는 N개 문제의 채점 결과를 나 타내는 0 혹은 1이 빈 칸을 사이에 두고 주어진다. 0은 문제의 답이 틀린 경우이고, 1은 문제의 답이 맞는 경우이다.▣ 출력설명첫째 줄에 입력에서 주어진 채점 결과에 대하여 가산점을 고려한 총 점수를 출력한다.▣ 입력예제 1101011100110▣ 출력예제 110풀이function solution(sheet) { let answer = 0; let correctStack = 0; for (check of sheet) { if (check === 1) { correctStack += 1; } else { correctStack = 0; } answer += correctStack; } return answer;}let sheet = [1, 0, 1, 1, 1, 0, 0, 1, 1, 0];console.log(solution(sheet)); // 10주어진 배열의 요소를 하나씩 돌면서 해당 요소가 1이라면 correctStack이라는 변수 값을 1씩 증가시킨다. 해당 요소가 0이라면 점수 스택이 초기화되야 하므로 correctStack 변수 값을 다시 0으로 초기화한다. 그리고 쌓아진 점수 스택(correctStack)은 항상 최종 결과값인 answer에 더해져야 하므로 조건과 상관 없이 answer+=correctStack을 이용해 하나의 요소를 돌 때마다 더해지도록 하였다." }, { "title": "가위바위보", "url": "/posts/%EA%B0%80%EC%9C%84%EB%B0%94%EC%9C%84%EB%B3%B4/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-06 13:20:00 +0900", "snippet": "문제A, B 두 사람이 가위바위보 게임을 합니다. 총 N번의 게임을 하여 A가 이기면 A를 출력하고, B가 이기면 B를 출력합니다. 비길 경우에는 D를 출력합니다.가위, 바위, 보의 정보는 1:가위, 2:바위, 3:보로 정하겠습니다.예를 들어 N=5이면 회수 1 2 3 4 5 A의 정보 2 3 3 1 3 B의 정보 1 1 2 2 3 승자 A B A B D 두 사람의 각 회의 가위, 바위, 보 정보가 주어지면 각 회를 누가 이겼는지 출력하는 프로그램을 작성하세요.▣ 입력설명첫 번째 줄에 게임 횟수인 자연수 N(1&lt;=N&lt;=100)이 주어집니다.두 번째 줄에는 A가 낸 가위, 바위, 보 정보가 N개 주어집니다.세 번째 줄에는 B가 낸 가위, 바위, 보 정보가 N개 주어집니다.▣ 출력설명각 줄에 각 회의 승자를 출력합니다. 비겼을 경우는 D를 출력합니다.▣ 입력예제 152331311223▣ 출력예제 1ABABD풀이function solution(A, B) { let answer = []; for (i = 0; i &lt; A.length; i++) { if (A[i] === B[i]) { answer.push(\"D\"); } else if (A[i] === 1 &amp;&amp; B[i] === 3) { answer.push(\"A\"); } else if (A[i] === 2 &amp;&amp; B[i] === 1) { answer.push(\"A\"); } else if (A[i] === 3 &amp;&amp; B[i] === 2) { answer.push(\"A\"); } else { answer.push(\"B\"); } } answer = answer.join(\" \"); return answer;}let A = [2, 3, 3, 1, 3];let B = [1, 1, 2, 2, 3];console.log(solution(A, B)); // A B A B D 먼저 A와 B중 누구를 기준으로 삼을지 정한다.(나는 A를 기준으로 하기로 정함) 가위:1, 바위:2, 보:3 이므로 이를 이용해 일단 A와 B 모두 같은 것을 내는 경우는 비기는 경우이므로 answer 배열에 ‘D’를 추가하도록 1차 조건을 걸어준다. 그 다음은 A가 각각 1, 2, 3을 낸 경우 B가 어떤 것을 내야 A가 이기는지 생각하여 조건문을 걸어주고 answer 배열에 ‘A’를 추가하도록 한다. A가 이기는 경우에 조건문을 걸어놨으니 else문에는 B가 이기는 경우만 남아있으므로 else로 오는 경우 answer 배열에 ‘B’를 추가한다. " }, { "title": "보이는 학생", "url": "/posts/%EB%B3%B4%EC%9D%B4%EB%8A%94-%ED%95%99%EC%83%9D/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-05 15:47:00 +0900", "snippet": "문제선생님이 N(1&lt;=N&lt;=1000)명의 학생을 일렬로 세웠습니다.일렬로 서 있는 학생의 키가 앞에 서부터 순서대로 주어질 때, 맨 앞에 서 있는 선생님이 볼 수 있는 학생의 수를 구하는 프로그램을 작성하세요. (앞에 서 있는 사람들보다 크면 보이고, 작거나 같으면 보이지 않습니다.)▣ 입력설명첫 줄에 정수 N이 입력된다.그 다음줄에 N명의 학생의 키가 앞에서부터 순서대로 주어진다.▣ 출력설명선생님이 볼 수 있는 최대학생수를 출력한다.▣ 입력예제 18130 135 148 140 145 150 150 153▣ 출력예제 15풀이function solution(input) { let answer = 1; let highest = input[0]; for (i = 1; i &lt; input.length; i++) { if (input[i] &gt; highest) { highest = input[i]; answer += 1; } } return answer;}let input = [130, 135, 148, 140, 145, 150, 150, 153];console.log(solution(input)); // 5맨 앞에 있는 학생은 무조건 보이게 되므로 highest 라는 변수를 하나 선언해 입력 배열의 첫 번째 인덱스(0)으로 지정해 둔 뒤 남은 입력 배열의 요소를 하나씩 돌면서 highest 변수의 값과 비교해 배열 안의 요소가 더 크다면 highest 변수 값을 갱신 해주고 answer의 카운트를 하나 올려주는 방식으로 구현하였다." }, { "title": "큰 수 출력하기", "url": "/posts/%ED%81%B0-%EC%88%98-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-04 11:47:00 +0900", "snippet": "문제N(1&lt;=N&lt;=100)개의 정수를 입력받아, 자신의 바로 앞 수보다 큰 수만 출력하는 프로그램을 작성하세요.(첫 번째 수는 무조건 출력한다)▣ 입력설명첫 줄에 자연수 N이 주어지고, 그 다음 줄에 N개의 정수가 입력된다.▣ 출력설명자신의 바로 앞 수보다 큰 수만 한 줄로 출력한다.▣ 입력예제 167 3 9 5 6 12▣ 출력예제 17 9 6 12풀이function solution(input) { let answer = []; answer.push(input[0]); for (i = 0; i &lt; input.length - 1; i++) { if (input[i] &lt; input[i + 1]) { answer.push(input[i + 1]); } } return answer;}let input = [7, 3, 9, 5, 6, 12];console.log(solution(input));// [7, 9, 6, 12]첫 요소는 무조건 배열에 push 하고, 그 다음 원소부터는 이전 원소와 비교해서 더 크다면 배열에 push 하는 방식으로 풀어냈다." }, { "title": "중복 단어 제거", "url": "/posts/%EC%A4%91%EB%B3%B5%EB%8B%A8%EC%96%B4%EC%A0%9C%EA%B1%B0/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-02 19:03:00 +0900", "snippet": "문제N개의 문자열이 입력되면 중복된 문자열은 제거하고 출력하는 프로그램을 작성하세요. 출력하는 문자열은 원래의 입력순서를 유지합니다.▣ 입력설명첫 줄에 자연수 N이 주어진다.(3&lt;=N&lt;=30)두 번째 줄부터 N개의 문자열이 주어진다. 문자열의 길이는 100을 넘지 않습니다.▣ 출력설명첫 줄부터 중복이 제거된 문자열을 차례로 출력한다.▣ 입력예제 15goodtimegoodtimestudent▣ 출력예제 1goodtimestudent풀이1. set을 이용한 중복 제거function solution(input) { let answer = [...new Set(input)]; return answer;}let input = [\"good\", \"time\", \"good\", \"time\", \"student\"];console.log(solution(input));// ['good', 'time', 'student']2. filter()를 이용한 중복 제거function sol2(input) { let answer; answer = input.filter((v, i) =&gt; { if (input.indexOf(v) === i) { return true; } }); return answer;}let input = [\"good\", \"time\", \"good\", \"time\", \"student\"];console.log(sol2(input));// ['good', 'time', 'student']filter()는 콜백 함수가 true를 리턴한 배열의 요소들을 따로 모은 것이다." }, { "title": "중복 문자 제거", "url": "/posts/%EC%A4%91%EB%B3%B5%EB%AC%B8%EC%9E%90%EC%A0%9C%EA%B1%B0/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-07-01 19:29:00 +0900", "snippet": "문제소문자로 된 한개의 문자열이 입력되면 중복된 문자를 제거하고 출력하는 프로그램을 작성하세요. 제거된 문자열의 각 문자는 원래 문자열의 순서를 유지합니다.▣ 입력설명첫 줄에 문자열이 입력됩니다.▣ 출력설명첫 줄에 중복문자가 제거된 문자열을 출력합니다.▣ 입력예제 1ksekkset▣ 출력예제 1kset풀이function solution(input) { let answer = \"\"; let string = new Set(input); for (i of string) { answer += i; } return answer;}let input = \"ksekkset\";console.log(solution(input));new Set()을 이용해 중복을 제거한 집합을 string에 담고 해당 집합의 요소를 for 문을 통해 읽으면서 answer에 추가해주었다.중복 제거 방법 set() filter(), indexOf() reduce(), includes() for() or forEach(), includes() Object.fromEntries(), map(), Object.keys()" }, { "title": "가운데 문자 출력하기", "url": "/posts/%EA%B0%80%EC%9A%B4%EB%8D%B0-%EB%AC%B8%EC%9E%90-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-06-19 15:41:00 +0900", "snippet": "문제소문자로 된 단어(문자열)가 입력되면 그 단어의 가운데 문자를 출력하는 프로그램을 작성하세요. 단, 단어의 길이가 짝수일 경우 가운데 2개의 문자를 출력합니다.▣ 입력설명첫 줄에 문자열이 입력된다.문자열의 길이는 100을 넘지 않습니다.▣ 출력설명첫 줄에 가운데 문자를 출력합니다.▣ 입력예제 1study▣ 출력예제 1u▣ 입력예제 2good▣ 출력예제 2oo풀이function solution(input) { let answer = \"\"; let mid = Math.floor(input.length / 2); // input 길이가 짝수인 경우 if (input.length % 2 == 0) { answer = input.slice(mid - 1, mid + 1); } else { // input 갈이가 홀수인 경우 answer = input.slice(mid, mid + 1); } return answer;}let input = \"study\";console.log(solution(input));알게 된 내용parseInt VS Math.floor주어진 수가 양수인 경우둘중 아무거나 사용해도 내림한 결과가 출력된다.주어진 수가 음수인 경우Math.floor: 소수 첫째 자리에서 양수일 때처럼 내림parseInt: 소수 첫째 자리에서 올림한다.(소수점을 버린다) Math.floor가 parseInt 보다 훨씬 빠르다! 추가 팁) Math.floor 보다는 ~~ 라는 연산자를 사용하면 더 빠르다.ex) let mid = ~~(input.length / 2);substr() VS subString() VS slice()substr()str.substr(start, length)시작 위치부터 해당 길이만큼 문자열을 자른다.subString()str.substring(indexStart, indexEnd)시작 위치에서 종료 위치의 -1 까지 문자열을 자른다.주의점substring() 함수에서 인자에 음수를 대입하면 해당 값은 0이 된다. 또한, 종료 위치에 음수 또는 0을 입력하는 경우 첫 번째 인수와 두 번째 인수가 서로 바뀐다.slice()str.slice(beginIndex, endIndex)기본적인 것은 substring() 함수와 동일하다. 다른 점은 음수를 사용할 때인데 slice()의 경우 음수 사용이 자유롭기 때문에 뒤에서부터 문자열을 자를 때 유용하게 사용할 수 있다.ex) slice(-1)을 하면 문자열의 맨 뒤에서부터 1개를 자르라는 의미. 즉, slice(-3)와 같은 경우 문자열의 맨 뒤에서부터 3개의 문자를 슬라이싱하라는 의미이다.(study의 경우 udy가 슬라이싱)" }, { "title": "가장 긴 문자열", "url": "/posts/%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EB%AC%B8%EC%9E%90%EC%97%B4/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-06-18 14:28:00 +0900", "snippet": "문제N개의 문자열이 입력되면 그 중 가장 긴 문자열을 출력하는 프로그램을 작성하세요.▣ 입력설명첫 줄에 자연수 N이 주어진다.(3&lt;=N&lt;=30)두 번째 줄부터 N개의 문자열이 주어진다. 문자열의 길이는 100을 넘지 않습니다. 각 문자열의 길이는 서로 다릅니다.▣ 출력설명첫 줄에 가장 긴 문자열을 출력한다.▣ 입력예제 15teachertimestudentbeautifulgood▣ 출력예제 1beautiful풀이function solution(num, input) { let answer = \"\"; let maxLength = Number.MIN_SAFE_INTEGER; for (word of input) { if (word.length &gt; maxLength) { maxLength = word.length; answer = word; } } return answer;}let num = 5;let input = [\"teacher\", \"time\", \"student\", \"beautiful\", \"good\"];console.log(solution(num, input));주어진 단어들의 개수만큼 input 배열에 넣은 뒤 for 문을 통해 배열의 각 요소를 돌면서 가장 긴 요소의 길이를 갱신해가며 가장 긴 길이를 가진 요소를 answer에 넣고 반환하도록 하였다." }, { "title": "대문자로 통일하기 & 대소문자 변환", "url": "/posts/%EB%8C%80%EB%AC%B8%EC%9E%90%EB%A1%9C-%ED%86%B5%EC%9D%BC-&-%EB%8C%80%EC%86%8C%EB%AC%B8%EC%9E%90-%EB%B3%80%ED%99%98/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-06-17 21:05:00 +0900", "snippet": "문제 1대문자와 소문자가 같이 존재하는 문자열을 입력받아 대문자로 모두 통일하여 문자열을 출력 하는 프로그램을 작성하세요.▣ 입력설명첫 줄에 문자열이 입력된다. 문자열의 길이는 100을 넘지 않습니다.▣ 출력설명첫 줄에 대문자로 통일된 문자열이 출력된다.▣ 입력예제 1ItisTimeToStudy▣ 출력예제 1ITISTIMETOSTUDY풀이function solution(input) { let answer = \"\"; answer = input.toUpperCase(); return answer;}let input = \"ItisTimeToStudy\";console.log(solution(input)); //ITISTIMETOSTUDY굳이 for문으로 주어진 문자열의 문자 하나하나 탐색해가며 바꿀 필요 없이 그냥 문자열 자체에 toUpperCase()를 적용해 한번에 대문자로 바꿀 수 있다.문제 2대문자와 소문자가 같이 존재하는 문자열을 입력받아 대문자는 소문자로 소문자는 대문자로 변환하여 출력하는 프로그램을 작성하세요.▣ 입력설명첫 줄에 문자열이 입력된다. 문자열의 길이는 100을 넘지 않습니다.▣ 출력설명첫 줄에 대문자는 소문자로, 소문자는 대문자로 변환된 문자열을 출력합니다.▣ 입력예제 1StuDY▣ 출력예제 1sTUdy풀이function solution(input) { let answer = \"\"; for (word of input) { if (word === word.toUpperCase()) { answer += word.toLowerCase(); } else if (word === word.toLowerCase()) { answer += word.toUpperCase(); } } return answer;}let input = \"StuDY\";console.log(solution(input)); //sTUdy주어진 문자열의 문자 하나하나를 for문을 통해 탐색하면서 해당 문자열이 대문자라면 toLowerCase()를 이용해 소문자로 바꿔서 answer에 추가해주고, 해당 문자열이 소문자라면 toUpperCase()를 이용해 대문자로 바꿔서 answer에 추가하는 작업을 한다." }, { "title": "대문자 찾기", "url": "/posts/%EB%8C%80%EB%AC%B8%EC%9E%90-%EC%B0%BE%EA%B8%B0/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-06-16 12:30:00 +0900", "snippet": "문제한 개의 문자열을 입력받아 해당 문자열에 알파벳 대문자가 몇 개 있는지 알아내는 프로그램 을 작성하세요.▣ 입력설명첫 줄에 문자열이 입력된다. 문자열의 길이는 100을 넘지 않습니다.▣ 출력설명첫 줄에 대문자의 개수를 출력한다.▣ 입력예제 1KoreaTimeGood▣ 출력예제 13풀이 1function solution(input) { let answer = 0; for (let word of input) { if (word === word.toUpperCase()) { answer += 1; } } return answer;}let input = \"KoreaTimeGood\";console.log(solution(input));풀이 1은 대문자를 찾는 정석 풀이로 toUpperCase()를 사용해 해당 문자를 대문자로 변경해준 후 기존 문자와 비교해 같다면 대문자이므로 그 때마다 answer를 하나씩 증가시켜주는 방식이다.풀이 2function solution2(input) { let answer = 0; for (let word of input) { // 아스키코드로 판별 가능(A-Z:65-90) let newWord = word.charCodeAt(); if (newWord &gt;= 65 &amp;&amp; newWord &lt;= 90) { answer += 1; } } return answer;}풀이 2는 아스키코드를 이용한 것으로 아스키코드에서 대문자 A는 65 Z는 90이므로 해당 문자가 65이상 90이하에 해당하는 아스키코드 값을 가지면 대문자인 것으로 판단하고 answer를 하나씩 증가시켜주는 방식이다." }, { "title": "A를 '#'으로", "url": "/posts/A%EB%A5%BC-%EC%9C%BC%EB%A1%9C/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-06-13 17:28:00 +0900", "snippet": "문제대문자로 이루어진 영어단어가 입력되면 단어에 포함된 ‘A’를 모두 ’#‘으로 바꾸어 출력하는 프로그램을 작성하세요.▣ 입력설명첫 번째 줄에 문자열이 입력된다.▣ 출력설명첫 번째 줄에 바뀐 단어를 출력한다.▣ 입력예제 1BANANA▣ 출력예제 1B#N#N#풀이 1function solution(input) { let answer = \"\"; for (let word of input) { if (word === \"A\") { answer += \"#\"; } else { answer += word; } } return answer;}// 입력 받은 값let input = \"BANANA\";// 답 출력console.log(solution(input));for 문을 통해 입력 받은 문자열을 하나하나 돌면서 A가 있다면 solution 함수가 반환할 값인 answer에 ‘#’을 추가해주고, A가 아니라면 해당 문자를 그대로 추가해준다.풀이 2function solution2(input) { input = input.replace(/A/g, \"#\"); return input;}// 입력 받은 값let input = \"BANANA\";// 답 출력console.log(solution2(input));replace와 정규식을 이용한 풀이로 입력 받은 값(input)에 있는 모든 A를 ‘#’로 바꾸어주라는 뜻의 정규식을 이용해 해당 값들을 모두 replace해준 것이다." }, { "title": "JS ES6 - 화살표 함수", "url": "/posts/JS-%ED%99%94%EC%82%B4%ED%91%9C%ED%95%A8%EC%88%98/", "categories": "Javascript ES6", "tags": "", "date": "2022-05-27 16:27:00 +0900", "snippet": "그냥 함수와 화살표 함수우리가 알던 함수의 기본 형태function() { console.log(\"Hello\");}화살표 함수의 형태const 함수 = () =&gt; { console.log(\"Hello\");};화살표 함수의 장점 입출력 기계를 만들고 싶을 때 사용직관적으로 쓸 수 있다. 또한, 파라미터가 1개면 ()를 생략할 수 있고, 실행 코드가 한줄이면 {}도 생략이 가능하다.const ReturnSum = (num) =&gt; { return num + 10;}; 코드들을 하나의 기능으로 묶고 싶을 때 사용(후에 재사용)함수의 사용과 this 연습하기Q1. Person 오브젝트 안에 sayHi 라는 메소드를 추가해 sayHi()를 실행하면 오브젝트 내에 있는 name에 해당하는 값이 출력되는 간단한 메소드를 만들어보자.let Person = { name: \"손흥민\", sayHi: function () { console.log(\"안녕 나는 \" + this.name); },};Person.sayHi(); // 안녕 나는 손흥민처음에 sayHi 메소드를 화살표 함수를 이용해 작성했는데 콘솔 창에 “안녕 나는” 밖에 출력되지 않았다. 그 이유를 생각해보니 전에 화살표 함수 안에 this를 이용하면 외부의 this를 이용하기 때문에 손흥민이라는 이름이 출력되지 않았던 것이다. 따라서 그냥 일반 함수를 사용해서 작성해줘야 “안녕 나는 손흥민”이 제대로 출력되게 된다.Q2. 오브젝트 내의 데이터를 전부 더해주는 메소드를 만들자.단, 조건이 있다. 자료라는 Object 중괄호 내에 코드를 작성하면 안된다.let 자료 = { data: [1, 2, 3, 4, 5],};// 이런식으로 외부에서 접근해서 추가 할 수 있음자료.AddAll = () =&gt; { let sum = 0; 자료.data.forEach((elem) =&gt; { sum += elem; }); console.log(sum);};자료.AddAll(); // 15위 코드에서 console.log(자료);를 해보면 {data: Array(5), AddAll: f}기 출력된다. 즉, 외부에서 만든 AddAll 함수가 자료 안에 들어가 있는것을 볼 수 있다.Q3. setTimeout을 이용해 버튼을 눌렀을 때 1초 후에 버튼 요소의 innerHTML을 출력하는 코드를 작성해보자.&lt;button id=\"버튼\"&gt;버튼이에요&lt;/button&gt;const btn = document.getElementById(\"btn\");btn.addEventListener(\"click\", function () { setTimeout(() =&gt; { console.log(this.innerHTML); }, 1000);});setTimeout의 콜백 함수로 화살표 함수를 사용해야 this를 사용했을 때, 외부에 있는 버튼을 잘 찾아올 수 있다.만약 그냥 일반 함수를 사용해서 작성한다면 이전에 공부한 이벤트 리스너 안에서 콜백 함수는 일반 함수 안의 this와 똑같이 취급되기 때문이라는 사실에 this는 window를 가리키게 되어 innerHTML값에 undefined를 내뱉을 것이다." }, { "title": "JS ES6 - this 키워드 (2)", "url": "/posts/JS-this-%ED%82%A4%EC%9B%8C%EB%93%9C(2)/", "categories": "Javascript ES6", "tags": "", "date": "2022-05-25 22:50:00 +0900", "snippet": "constructor 안에서 사용하는 thisconstructor 안에서 this를 사용하는 경우 이는 새로 생성되는 오브젝트를 의미한다.class Member { constructor() { this.name = \"Kim\"; }}let member1 = new Member();console.log(member1.name); // \"Kim\"Event Listener 안에서 사용하는 this이벤트 리스너 안에서 this를 사용하는 경우 이는 e.currentTarget과 같은 의미로 사용된다.&lt;button id=\"btn\"&gt;버튼&lt;/button&gt;// 1번document.getElementById(\"btn\").addEventListener(\"click\", function () { this; // &lt;button id=\"btn\"&gt;버튼&lt;/button&gt; console.log(this);});// 2번document.getElementById(\"btn\").addEventListener(\"click\", function (e) { e.currentTarget; // &lt;button id=\"btn\"&gt;버튼&lt;/button&gt; console.log(e.currentTarget);});위 코드에서 1번과 2번은 거의 동일한 코드라고 생각하면 된다.이벤트 리스너 안에서 콜백함수를 쓰는 경우 this는?document.getElementById(\"btn\").addEventListener(\"click\", function (e) { let arr = [1, 2, 3]; arr.forEach(function () { // 콜백 함수 console.log(this); });});이벤트 리스너 안에 있긴 하지만, 그 안에서 함수를 하나 더 만났기 때문에 의미가 다르다. 저렇게 기본적인 콜백함수는 이전에 배운 그냥 일반함수 안의 this와 똑같이 취급되기 때문에 window가 출력된다.그럼 오브젝트 안에서 콜백함수를 쓸 때 this는?let Object = { names : ['김', '이', '박']; func : function(){ // 1번 this console.log(this); Object.names.forEach(function(){ // 2번 this console.log(this); }); }}1번 this 의 경우 해당 메소드(함수)를 담고 있는 오브젝트를 가리키기 때문에 Object ({names: Array(3), func: f}) 가 출력될 것이다.2번 this 의 경우 콜백 함수이기 때문에 window가 출력될 것이다.this값은 새로운 function을 만날 때마다 바뀔 수 있다위에서 살펴본 것처럼 this는 새로운 함수를 만날 떄마다 계속 바뀔 수 있기 때문에 원하는 this를 사용하는 것이 어려울 수 있다. 이럴때는 해당 함수를 화살표 함수로 바꾸어보자!let Object = { names : ['김', '이', '박']; func : function(){ // 1번 this console.log(this); Object.names.forEach(() =&gt; { // 2번 this console.log(this); }); }}위 코드처럼 화살표 함수를 사용한 경우, 1번 this가 출력해주는 내용을 2번 this도 동일하게 출력한다.즉, 화살표 함수를 이용하면 함수 내부의 this 값을 새로 바꿔주지 않기 때문에 (외부 this 값을 그대로 재사용 가능하다는 의미) 원하는 this를 사용하고 싶을 때 유용하다." }, { "title": "JS ES6 - this 키워드 (1)", "url": "/posts/JS-this-%ED%82%A4%EC%9B%8C%EB%93%9C/", "categories": "Javascript ES6", "tags": "", "date": "2022-05-22 19:38:00 +0900", "snippet": "this의 뜻 결론부터 말하면, this 키워드는 자신을 담고있는 오브젝트를 출력해주는 역할을 한다.this를 어느곳에도 담지 않고 그냥 사용하는 경우console.log(this); // window {...}this를 일반 함수 내에서 사용하는 경우function Test() { console.log(this);}Test(); // window {...}왜 window 객체가 출력되는가?window란 모든 전역변수, 함수, DOM을 보관하고 관리하는 하나의 커다란 오브젝트이다. 앞에서 this는 자신을 담고 있는 오브젝트를 출력해주는 키워드라고 했다. 따라서 자신을 담고 있는 오브젝트가 window이기 때문에 얘를 출력해주는 것인데, 여기서 알 수 있는 점은 자바스크립트로 함수나 변수와 같은 것을 전역 공간에서 만들면 모두 {window} 안에 보관하게 된다는 것이다.// 이런식으로 커다란 window{} 안에 모두 들어가게 된다.window: { let value = ''; function(){ console.log(); }} 참고: strict mode 일 때 함수 안에서 this를 쓰면 undefined를 출력한다.object 자료형 내 메소드에서 this를 사용하는 경우위에서 설명한 내용을 적용하면 어떤 값을 출력해주는지 쉽게 알 수 있다.만약 아래와 같은 오브젝트가 있다고 가정해보자.let Object1 = { data: \"Kim\", newFunc: function () { console.log(this); },};위 객체 안의 함수를 실행시켜보면Object1.newFunc(); // {data: 'Kim', newFunc: f}이렇게 출력된다. {data: ‘Kim’, newFunc: f} == Object1 이므로, 이를 통해 어떤 오브젝트 안에 존재하는 메소드(함수) 내에서 this를 사용하면 해당 메소드를 가지고 있는 오브젝트를 가리킨다는 것을 알 수 있다.마찬가지로 오브젝트 안에 오브젝트가 있고 그 안에 새로운 메소드가 존재하고 그 안에서 this를 호출한다고 가정해보자.let Object2 = { data: { newFunc2: function () { console.log(this); }, },};Object2.data.newFunc2(); // ?오브젝트 안에 존재하는 메소드 안에서 this를 호출하면, this는 자신을 담고 있는 오브젝트를 출력하므로 아래와 같은 값을 출력할 것이다.Object2.data.newFunc2(); // {newFunc2: f}Q. 만약 Arrow Function 안에서 this를 사용하면 어떻게 될까?let Object2 = { data: { newFunc2: () =&gt; { console.log(this); }, },};Object2.data.newFunc2(); // {window}this 값을 함수 밖에 있던걸 그대로 쓴다." }, { "title": "Typescript interface 문법", "url": "/posts/TS-interface-%EB%AC%B8%EB%B2%95/", "categories": "Typescript", "tags": "", "date": "2022-05-20 18:25:00 +0900", "snippet": "전에 type 키워드로 타입변수를 생성할 수 있다는 것을 배웠다. 오늘은 interface 라는 것에 대한 공부를 할 것인데, 이 키워드도 타입변수를 생성할 수 있다.interface 문법object 타입지정시 사용 가능하다.// 이전까지 object에 타입지정하던 방법type Square = { color: string; width: number };let square: Square = { color: \"red\", width: 100 };// interface 문법을 사용하여 타입지정하는 방법interface Square { color: string; width: number;}interface의 장점 - extendsinterface Student { name: string;}// Students interface가 가지고 있는 속성을// Teacher에 복사해서 넣어라interface Teacher extends Student { aeg: number;}let student: Student = { name: \"kim\" };let teacher: Teacher = { name: \"lee\", age: 24 };intersection typetype alias 문법도 interface의 extends와 비슷한 행동을 하도록 할 수 있다. 바로 &amp; 기호를 사용하는 것인데,type Animal = { name: string };type Cat = { age: number } &amp; Animal;이런식으로 하나의 타입변수를 만든 후 다른 하나의 타입변수에 &amp; 기호를 이용해 서로 묶어주면 Cat 라는 타입변수는 Animal 타입의 속성도 가지게 된다.하지만 주의할점&amp; 기호를 사용하는 것은 extends랑은 다른 의미를 가지고 있음에 주의해야 한다. &amp; 기호: intersection type으로 두 타입을 전부 만족하는 타입이라는 뜻 (복사해달라는 뜻 아님) extends: 다른 하나가 가지고 있는 것을 복사해서 넣어달라는 뜻 그리고 interface도 &amp; 기호를 사용 가능함.그래서 type과 interface 차이는? interface: 중복선언 가능 type: 중복선언 불가능예를들어 interface는interface Student { name: string;}interface Student { score: number;}이렇게 같은 이름을 가진 interface가 하나 이상 있어도 에러가 나지 않고, extends 한 것이랑 동일하게 Student라는 타입에는 name과 score가 모두 들어가도록 합쳐진다.반면, type은 엄격해서 에러를 뱉는다. interface는 type 선언을 자주 사용하는 외부 라이브러리 이용시 type 선언을 내가 override 하기 편함!interface 이름 중복만 허용이지 안의 속성이 중복되는 경우에는 에러가 발생함에 주의실습 해보기Q1. interface 이용해서 간단한 타입을 만들어보자.// 요것의 타입지정을 해보자let prod = { brand: \"Samsung\", serialNumber: 1360, model: [\"TV\", \"phone\"] };// interfaceinterface ProductType { brand: string; serialNumber: number; model: string[];}let prod: ProductType = { brand: \"Samsung\", serialNumber: 1360, model: [\"TV\", \"phone\"],};Q2. 아래처럼 생긴 object들이 잔뜩 들어갈 수 있는 array의 타입지정을 interface 문법을 사용해서 해보자.let cart = [ { product: \"청소기\", price: 7000 }, { product: \"삼다수\", price: 800 },];// 타입은 그냥 이렇게 만들고interface Cart { product: string; price: number;}// 만든 타입 사용할 때 array 타입으로 사용하면 됨let cart: Cart[] = [ { product: \"청소기\", price: 7000 }, { product: \"삼다수\", price: 800 },];Q3. 위에서 만든 타입을 extends 해보자. 갑자기 서비스가 업데이트되어 일부 상품에는 card 속성이 들어가게 되었다.// 기존interface Cart { product: string; price: number;}// extendsinterface newCart extends Cart { card: boolean;}" }, { "title": "Typescript 클래스 만들 때 타입 지정하기", "url": "/posts/class-%EB%A7%8C%EB%93%A4-%EB%95%8C-%ED%83%80%EC%9E%85-%EC%A7%80%EC%A0%95/", "categories": "Typescript", "tags": "", "date": "2022-05-19 20:02:00 +0900", "snippet": "클래스의 타입을 지정하는 방법을 알아보기 전에 자바스크립트의 class와 prototype을 정리하고 가자.자바스크립트의 Class 문법가끔 비슷한 구조의 object를 많이 생성할 일이 있는데 이 때 class 문법을 사용하면 편리하다.새로운 객체 생성 시 class 문법을 사용하지 않는 경우let newObject1 = { q: \"consume\", w: \"snowball\",};let newObject2 = { q: \"strike\", w: \"courage\",};let newObject3 = {...}이런식으로 하나하나 작성해가면서 생성해야하는 번거로움이 존재한다.새로운 객체 생성 시 class 문법을 사용하는 경우function 오브젝트생성기계() { this.q = \"consume\"; this.w = \"snowball\";}let newObject1 = new 오브젝트생성기계();let newObject2 = new 오브젝트생성기계();여기서 this는 새로 생성되는 object들이라고 생각하면 된다. 즉, 새로 생성되는 object에 {q: ‘consume’, w: ‘snowball’}을 추가해주라는 의미라고 생각하면 된다.앞서 여러줄이나 되는 코드를 통해 새 객체를 생성한 반면, class 문법을 사용한 경우는 미리 지정해둔 새 오브젝트 생성 기계 함수를 통해 고작 한 줄로 새로운 객체를 생성할 수 있다.그런데! 코드를 저렇게만 작성하면 newObject1과 newObject2 그리고 이후에 생겨날 새로운 객체들도 모두 동일한 q,w 속성값을 갖게 된다.따라서 ES6 이후 contructor 함수가 생겨나면서 아래와 같은 방법을 사용할 수 있게 되었다.class Hero { constructor(q, w) { this.q = q; this.w = w; }}자바스크립트의 prototype 문법prototype === '유전자' 라고 생각하면 좋은 것 같다.function 오브젝트생성기계() { this.q = \"consume\"; this.w = \"snowball\";}오브젝트생성기계.prototype.name = \"kim\";let newObject1 = new 오브젝트생성기계();console.log(newObject1.name); // \"kim\"부모의 prototype, 즉 부모의 유전자에 name 속성을 추가하면 모든 자식들은 그 속성을 물려받아 사용 가능하다.이런 방법을 통해 원하는 자료(ex. array)에 새로운 prototype을 추가해 해당 자료에서 사용할 수 있는 함수를 추가하는 등의 행동을 통해 조금 더 자유로운 코딩을 할 수 있게 된다!이제 본격적으로 타입스크립트로 돌아가보자!class 필드값 타입 지정하기// 사실 이대로 놔둬도 알아서 number 타입으로 지정해줌class Person { data = 0;}// 근데 굳이 명시하고 싶으면 아래처럼class Person { data: number = 0;}constructor 타입 지정하기// 타입스크립트에서는 이거 에러남class Person { constructor() { this.name = \"kim\"; this.age = 20; }}타입스크립트에서는 this.어쩌고를 사용하고 싶으면 어쩌고 부분을 미리 필드값으로 만들어줘야한다.class Person { // 이렇게 미리 필드값으로 만들어두기 name; age; constructor() { this.name = \"kim\"; this.age = 20; }}그리고 constructor 함수에는 파라미터를 전달할 수 있는데, 이때 파라미터에도 타입 지정을 할 수 있다.class Person { name; age; constructor(a: string) { this.name = a; this.age = 20; }}class 내부 methods 타입 지정하기class 내부에도 함수를 넣을 수 있다.class Person { add(age: number): void { console.log(age + 1); }}class 안의 함수도 이런식으로 그냥 이전에 했던 함수랑 똑같이 타입 지정해주면 된다.실습 해보기Q1. 아래의 조건을 만족하는 Car 클래스 만들기 {model: ‘소나타, price: 3000} 이런 구조의 object를 복사해주는 Class를 생성하자. 복사된 object 자료들은 .tax() 라는 함수를 사용할 수 있다 . 이때 이 함수는 현재 object에 저장된 price의 1/10을 출력해주는 함수다. model과 price 속성, tax()함수의 return 타입 지정도 해보자.class Car { model: string; price: number; constructor(model, price) { this.model = model; this.price = price; } // 함수는 밖에다 tax(): number { return this.price * 0.1; }}Q2. class인데 파라미터가 잔뜩 들어가는 class Word를 만들어보자. object 만들 때 new Word() 소괄호 안에 숫자 혹은 문자를 입력하면 숫자는 전부 object 안의 num 속성 안에 array 형태로 저장되고 문자는 전부 object 안의 str 속성 안에 array 형태로 저장된다. 이런 class를 만들어보자.class Word { num; str; // ...params도 타입 정해주고 constructor(...params: (number | string)[]) { let numArray: number[] = []; let strArray: string[] = []; this.num = numArray; this.str = strArray; // 얘도 constructor 안에 넣어야함 params.forEach((elem) =&gt; { if (typeof elem === \"number\") { numArray.push(elem); } else if (typeof elem === \"string\") { strArray.push(elem); } }); }}처음에 constructor(...params: number | string) {} 으로 했더니 rest 매개 변수는 배열 형식이어야 합니다. 라는 오류 뜸. 그래서 number | string)[] 로 변경함" }, { "title": "Typescript HTML 변경, 조작 시 주의할 점", "url": "/posts/TS%EB%A1%9C-HTML-%EB%B3%80%EA%B2%BD%EA%B3%BC-%EC%A1%B0%EC%9E%91%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%A0%90/", "categories": "Typescript", "tags": "", "date": "2022-05-17 15:06:00 +0900", "snippet": "strictNullCheck 옵션tsconfig.json의 compilerOptions 안에 \"strictNullChecks\": true 라는 옵션을 주면 변수 조작 전 해당 값이 null 인지 아닌지 검사를 할 수 있다. 혹은 \"strict\": true 라는 옵션을 주면 strictNullChecks 옵션도 자동으로 true로 설정된다.이런 null 값 검사는 특히 html을 조작할 때 selector를 이용해 찾게 되는 경우 유용하다.자바스크립트와 HTML vs 타입스크립트와 HTML먼저, h4 태그 안의 제목을 다른 글자로 변경하는 일을 해야한다고 가정해보자.기본 자바스크립트의 경우let Title = document.querySelector(\"#title\");Title.innerHTML = \"새로운 제목\";이렇게 작성하면 기존 제목을 새로운 제목으로 변경할 수 있다.타입스크립트의 경우let Title = document.querySelector(\"#title\");// 오류 발생!Title.innerHTML = \"새로운 제목\";타입스크립트로 똑같이 작성했을 경우 오류가 발생하게 된다. 그 이유는 Title이라는 변수가 null일 수 있기 때문이다.이는 셀렉터를 이용해 html을 찾으면 타입이 Element | null이기 때문에 아직 타입이 확실하지 않아 해당 값을 조작하는 것을 금지시켜주기 때문에 발생하는 오류이다.해결법은 Title이라는 변수가 Element | null 타입 즉, union type이기 때문에 type narrowing을 하면 된다.Type Narrowing을 사용하는 방법let Title = document.querySelector(\"#title\");if (Title != null) { Title.innerHTML = \"새로운 제목\";}위의 방법 외에 4가지 방법이 더 있는데 아래와 같다.instanceof 사용한 narrowing 방법 ⭐️⭐️⭐️let Title = document.querySelector(\"#title\");if (Title instanceof HTMLElement) { Title.innerHTML = \"새로운 제목\";}Assertion을 사용하는 방법let Title = document.querySelector(\"#title\") as HTMLElement;Title.innerHTML = \"새로운 제목\";optional chaining 연산자let Title = document.querySelector(\"#title\");if (Title?.innerHTML != undefined) { Title.innerHTML = \"새로운 제목\";}? 연산자는 왼쪽에 있는 object 자료 안에 .innerHTML이 존재하면 해당 값을 써주고 없으면 undefined를 남겨라! 라는 의미이다.그냥 strict 설정을 false로 끄기위의 방법 중에 가장 추천하는 방법은 instanceof 연산자를 쓰는 방법이다. 왜냐하면 이 연산자를 써야 조작이 가능한 부분이 존재하기 때문인데 아래 예시를 들 수 있다.a 태그의 href 속성을 변경하는 경우// html 파일에 이런 태그가 있다고 가정&lt;a href=\"naver.com\"&gt;&lt;/a&gt;;// 여기서부터는 ts 파일let Link = document.querySelector(\"#link\");if (Link instanceof HTMLElement) { Link.href = \"https://kakao.com\"; // 에러 발생}href는 HTMLElement타입에 존재하지 않는다. 라는 오류를 뱉는다.즉, href를 narrowing 할 때는 HTMLElement가 아닌 HTMLAnchorElement 타입을 사용해야 한다.let Link = document.querySelector(\"#link\");if (Link instanceof HTMLAnchorElement) { Link.href = \"https://kakao.com\";}위 예시를 통해 알 수 있는 것은 html 태그는 그 종류별로 정확한 타입 명칭을 가지고 있다는 점이다. 따라서 태그에 맞는 정확한 타입으로 narrowing 해줘야 타입스크립트에서 html 속성을 제대로 수정할 수 있다. 정리: 타입스크립트로 HTML 속성을 변경할 때에는 변경할 태그에 맞는 정확한 타입으로 narrowing 해줘야한다.타입스크립트에서 이벤트 리스너 부착하기타입스크립트에서 버튼을 누르면 X를 실행해 주세요! 이런 이벤트 리스너를 사용할 때에도 타입 지정을 해줘야 제대로 사용이 가능하다.let Btn = document.getElementById(\"button\");// optional chaining 사용Btn?.addEventListener(\"click\", function () { console.log(\"안녕\");});이렇게 이벤트를 수행할 변수 옆에 ? 연산자를 붙이면 일종의 narrowing으로 인식하여 해결이 되긴한다. 이는 Btn이라는 변수에 addEventListener의 수행이 가능하면 해주고, 아니면 undefined를 뱉으라는 의미이다.실습 해보기Q1. 버튼을 누르면 이미지를 바꾸는 코드를 짜보자.&lt;!-- 이런 html 태그가 있음 --&gt;&lt;img id=\"image\" src=\"test.jpg\" /&gt;// 답안let Image = document.querySelector(\"#image\");if (Image instanceof HTMLImageElement) { Image.src = \"new.jpg\";}Q2. 바꾸고 싶은 html 요소가 여러개 있다. 이 요소들의 href 속성을 전부 https://kakao.com으로 바꾸고 싶다. 어떻게 해야할까?&lt;!-- 이런 html 태그가 있음 --&gt;&lt;a class=\"naver\" href=\"naver.com\"&gt;링크&lt;/a&gt;&lt;a class=\"naver\" href=\"naver.com\"&gt;링크&lt;/a&gt;&lt;a class=\"naver\" href=\"naver.com\"&gt;링크&lt;/a&gt;// 답안let Link = document.querySelectorAll(\".naver\");Link.forEach((link) =&gt; { if (link instanceof HTMLAnchorElement) { link.href = \"https://kakao.com\"; }});" }, { "title": "Typescript 함수와 methods에 type alias 지정하기", "url": "/posts/TS-%ED%95%A8%EC%88%98%EC%99%80-methods%EC%97%90-type-alias-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0/", "categories": "Typescript", "tags": "", "date": "2022-05-16 23:30:00 +0900", "snippet": "함수 타입도 type alias로 지정할 수 있다type FuncType = (x: number, y: number) =&gt; number;이렇게 화살표 함수를 이용해서 만든다.이제 만든 함수 타입을 부착하려면 함수 표현식을 사용해야 한다.let funcName: FuncType = function () {};정리하면 아래와 같다. 함수 타입은 () =&gt; {} 형태로 만든다. 함수 표현식에만 만든 type alias 사용이 가능하다.methods 안에 타입 지정하기object 안에 함수를 만들 수 있다는 사실을 알고 있는가?let memberInfo = { name: \"kim\", plusOne() { // 이렇게 함수 지정이 가능함 }, // 화살표 함수도 가능 changeName: () =&gt; {},};// 함수를 사용할 때는 이렇게memberInfo.plusOne();Q1. 위처럼 사용할 수 있는데 이렇게 object 안에 있는 함수의 타입 지정은 어떻게 할까? 아래 조건을 만족하도록 memberInfo 변수에 타입 지정을 해보자. plusOne 속성은 함수이고, 숫자를 넣어서 숫자를 반환하는 함수여야한다. changeName 속성은 함수이고, 아무것도 반환해서는 안된다.type MemberInfoType = { name: string; plusOne: (x: number) =&gt; number; changeName: () =&gt; void;};let memberInfo: MemberInfoType = { name: \"kim\", plusOne() {}, changeName: () =&gt; {},};실습 해보기Q2. 아래 조건을 만족하는 함수 2개를 만들어보고 타입을 정의해보자. cutZero() 라는 함수를 만들자. 이 함수는 문자를 하나 입력했을 때, 맨 앞에 ‘0’이 있으면 이를 제거하고 문자 타입으로 반환해준다. removeDash() 라는 함수를 만들자. 이 함수는 문자를 하나 입력했을 때 ‘-‘가 있다면 이를 전부 제거하고 숫자 타입으로 반환한다. 함수에 타입 지정 시 type alias를 사용한다.// cutZero 함수 타입type cutZeroType = (x: string) =&gt; string;// removeDash 함수 타입type removeDashType = (x: string) =&gt; number;// fuction cutZerolet cutZero: cutZeroType = (x) =&gt; { let answer = x.replace(/^0+/, \"\"); return answer;};// function removeDashlet removeDash: removeDashType = (x) =&gt; { let answer = x.replace(/-/g, \"\"); return parseInt(answer);};Q3. Q2 에서 만든 함수들을 파라미터로 넣을 수 있는 함수를 제작하고 싶다. 이 때 이 함수는 파라미터 3개가 들어가는데 첫째는 문자, 둘째와 셋째는 함수를 집어넣을 수 있다. 이 함수를 실행하면 아래와 같은 동작을 수행하게 된다. 첫째 파라미터를 둘째 파라미터에 파라미터로 집어넣는다. 둘째 파라미터에서 반환된 결과를 셋째 파라미터에 집어넣는다. 셋째 파라미터에서 반환된 결과를 콘솔창에 출력한다.그리고 둘째 파라미터에는 cutZero, 셋째 파라미터엔 removeDash 라는 함수들만 입력할 수 있게 파라미터의 타입도 지정해보자.// 둘째 파라미터에 들어올 함수 타입 지정type func1Type = (x: string) =&gt; string;// 셋째 파라미터에 들어올 함수 타입 지정type func2Type = (x: string) =&gt; number;// 원하는 조건의 동작을 수행할 함수의 타입 지정type newFuncType = (x: string, func1: func1Type, func2: func2Type) =&gt; void;// 원하는 조건의 동작을 수행할 메인 함수let newFunc: newFuncType = (x, func1, func2) =&gt; { let answer = func1(a); let result = func2(answer); console.log(result);};newFunc(\"010-1111-2222\", cutZero, removeDash);Q2 에서 작성한 코드와 합친 전체 코드 답안type cutZeroType = (x: string) =&gt; string;type removeDashType = (x: string) =&gt; number;let cutZero: cutZeroType = (x) =&gt; { let answer = x.replace(/^0+/, \"\"); return answer;};let removeDash: removeDashType = (x) =&gt; { let answer = x.replace(/-/g, \"\"); return parseInt(answer);};type func1Type = (x: string) =&gt; string;type func2Type = (x: string) =&gt; number;type newFuncType = (x: string, func1: func1Type, func2: func2Type) =&gt; void;let newFunc: newFuncType = (x, func1, func2) =&gt; { let answer = func1(x); let result = func2(answer); console.log(result);};newFunc(\"010-1111-2222\", cutZero, removeDash);" }, { "title": "Typescript Literal Types", "url": "/posts/TS-Literal-Types/", "categories": "Typescript", "tags": "", "date": "2022-05-15 21:26:00 +0900", "snippet": "Literal Typesstring, number, boolean과 같은 것만 타입이 될 수 있는것이 아니다. 일반 글자같은 것도 타입이 될 수 있다.// 이런식으로 원하는 타입을 만들 수 있다.// student랑 office worker라는 타입을 만든 것이다.let me: \"student\";let you: \"office worker\";이렇게 작성하면 이제 me 라는 변수에는 student라는 글자만 할당할 수 있고, you 라는 변수에는 office worker라는 글자만 할당할 수 있다. (or 기호를 사용한 union type도 지정 가능)또한 함수도 마찬가지로 원하는 타입으로 지정해줄 수 있다.function func(a: \"hello\"): 1 | 0 | -1 { return 1;}파라미터 타입 선언 시 글자나 숫자를 넣으면 해당 타입만 파라미터로 넣을 수 있고 return 타입 선언 시에도 글자나 숫자를 넣으면 해당 타입만 return 할 수 있다.이렇게 특정 글자나 숫자만 가질 수 있게 제한을 두는 것을 Literal Type 이라고 한다.즉, 정리해보면 Literal Type 은 들어올 수 있는 자료를 미리 정해(제한해)두는 것 변수에 뭐가 들어올지 더 엄격하게 관리 가능const 변수의 한계const 변수는 2개 이상의 값을 저장하지 못함. 그러나 Literal Type 쓰면 or 기호를 통해 2개 이상의 값을 저장할 수 있음.Literal Type의 문제점과 as const만약 아래와 같은 과정이 있다고 가정해보자.let object = { name: \"kim\",};function func(a: \"kim\") {}func(\"kim\"); // OKfunc(object.name); // Error위의 코드를 보면 분명 object.name == ‘kim’ 이다.그런데 func(‘kim’)은 오류가 나지 않지만, func(object.name)은 object.name이 ‘kim’ 인데도 불구하고 에러가 발생한다.이러한 오류가 발생하는 이유는 바로 (a: 'kim')이라고 지정한 것은 'kim'이라는 자료만 들어올 수 있다가 아닌 'kim'이라는 타입만 들어올 수 있다를 의미하기 때문이다.따라서 object.name은 타입이 'kim'이 아닌 string이기 때문에 오류가 발생한다고 할 수 있다.이러한 문제를 해결하기 위한 해결책에는 크게 3가지가 있다.해결책(1)object 만들 때 직접 하나하나 타입 지정을 확실하게 해준다.해결책(2)Assertion 문법을 사용해 as 문법으로 타입을 속인다.해결책(3)as const 라는 키워드를 사용한다.let object = { name: \"kim\",} as const;as const는 해당 속성의 타입을 오른쪽에 있는 값으로 지정해주라는 의미를 가지고 있다. 또한 object 속성들에 모두 readonly를 붙여준다.실습 해보기Q1. 아래 조건에 맞는 함수를 작성해보자. ‘가위’, ‘바위’, ‘보’ 문자들만 파라미터로 입력할 수 있다. ‘가위’, ‘바위’, ‘보’ 라는 문자들만 담을 수 있는 array 자료만 return 할 수 있다. 예를 들어 [‘가위’, ‘보’, ‘가위’]와 같이 return 가능하다. [‘가위’, ‘바보’] 이런거 return 하면 에러가 발생해야 한다.function RCP(x: \"가위\" | \"바위\" | \"보\"): (\"가위\" | \"바위\" | \"보\")[] { return [\"가위\", \"보\"];}" }, { "title": "Typescript 변수에 타입 담아서 사용하기", "url": "/posts/TS-%ED%83%80%EC%9E%85%EC%9D%84-%EB%B3%80%EC%88%98%EC%97%90-%EB%8B%B4%EC%95%84%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/", "categories": "Typescript", "tags": "", "date": "2022-05-12 12:50:00 +0900", "snippet": "Type alias (타입 별칭)let animal: string | number | undefined;위 코드처럼 하나의 변수에 해당하는 타입이 긴 경우 타입 자체를 변수로 선언해 선언한 타입 변수를 가져다가 사용하게 할 수 있다.타입 변수는 type 키워드로 시작하며 아래와 같이 선언할 수 있다.// 이렇게 타입 변수 선언type AnimalType = string | number | undefined;// 선언한 타입을 사용할 변수에 사용let animal: AnimalType = 123;객체 타입도 이렇게 타입 변수에 담을 수 있다.type AnimalType = { name: string; age: number };let animal: AnimalType = { name: \"Pig\", age: \"4\" };object readonly 속성Javascript에서 const 변수는 재할당을 막는 키워드지, const로 담은 객체의 수정을 막는 키워드는 아니다.// 이런 재할당은 안되지만const area = \"seoul\";area = \"seoul\";// 이렇게 안의 객체를 수정하는 것은 가능하다.const area = { region: \"seoul\" };area.region = \"busan\";그러나 Typescript에서는 readonly 속성을 이용해 이러한 객체의 수정도 막을 수 있다.type GirlFriend = { readonly name: string}const girlfriend: GirlFriend { name: '엠버'}// 여기서 오류 발생girfriend.name = '유라'하지만, readonly를 사용한다 해도 컴파일시 에러를 발생시키는 것일 뿐, 실제로는 값이 바뀜에 주의해야한다.Type alias extend타입 변수도 union type으로 합치기가 가능하다.type Name = string;type Age = number;// 그러면 Person이란 타입은 string | Numbertype Person = Name | Age;&amp; 연산자로 객체 타입을 합치는 것도 가능하다.type PositionX = { x: number };type PositionY = { y: number };// {x: number, y: number}type NewType = PositionX &amp; PositionY;주의할 점기본적으로 같은 이름의 type 변수는 재정의가 불가능하다.다만, 후에 배울 interface라는 키워드를 사용하면 재정의가 가능하다.실습 해보기Q1. object 타입을 정의한 type alias 2개를 &amp; 기호로 합칠 때 중복된 속성이 있으면 어떻게 될까?A1. 개체 리터럴은 이름이 같은 여러 속성을 가질 수 없습니다.라는 오류 메시지가 출력된다.Q2. 다음 조건을 만족하는 타입을 만들어보자. object 자료형이여야한다. color 라는 속성을 가질 수도 있으며 항상 문자가 들어와야한다. size 라는 속성이 있어야하며 항상 숫자가 들어와야한다. position 이라는 변경 불가능한 속성이 있어야하며 항상 숫자가 담긴 array 자료가 들어와야한다.type NewType = { color?: string; size: number; readonly position: number[];};Q3. 다음을 만족하는 type alias를 만들어보자. { name : ‘kim’, phone : 123, email : ‘abc@naver.com’ } 이렇게 생긴 자료들을 다룰 일이 많다. object 안에 잇는 이름, 전화번호, 이메일 속성이 옳은 타입인지 검사하는 type alias를 만든다. 각 속성이 어떤 타입일지는 자유롭게 정한다.type InfoCheck = { name: string; phone: number; email: string;};Q4. 다음을 만족하는 type alias를 만들어보자. 이름, 전화번호, 이메일, 미성년자 여부 속성이 옳은 타입인지 검사하는 type alias를 만든다. 미성년자 여부 속성은 true/false만 들어올 수 있다.방법 1type InfoCheck = { name: string; phone: number; email: string; isAdult: boolean;};방법 2type InfoCheck = { name: string; phone: number; email: string; isAdult: boolean;};type adultCheck = { isAdult: boolean;};type NewCheck = InfoCheck &amp; adultCheck;" }, { "title": "Typescript Narrowing & Assertion", "url": "/posts/TS-Narrowing&Assertion/", "categories": "Typescript", "tags": "", "date": "2022-05-09 19:07:00 +0900", "snippet": "Type NarrowingType이 아직 하나로 확정되지 않았을 경우(ex. union type) 사용한다.function Test(x: number | string) { // 파라미터 타입이 number인 경우 if (typeof x === \"number\") { return x + 1; // 파라미터 타입이 string인 경우 } else if (typeof x === \"string\") { return x + 1; // 그 외의 경우 } else { return 0; }}위처럼 if, else if, else 구문과 typeof를 사용해서 작성하는 것이 대표적인 Narrowing 방법이지만, in, instanceof 키워드를 사용한 Narrowing 방법도 있다.Type Assertion타입을 덮어쓰는 문법으로 해당 변수의 타입을 X로 생각해주세요. 라는 의미이다. 얘는 그냥 타입을 X처럼 생각해주라고 주장하는 역할을 하지 실제로 타입을 X로 바꿔주는 역할은 하지 않는다.function 내함수(x: number | string) { // as를 사용한 여기가 Assertion 문법 return (x as number) + 1;}console.log(내함수(123));그런데 편하다고 막 쓰면 안되고 이것의 용도는 아래와 같다. union type과 같은 여러개의 복잡한 타입을 하나로 확정짓고 싶을 때 사용한다. 어떤 타입이 들어올지 100% 확실하게 알고 있을 때 쓴다.결론적으로는 딱히 쓸 일이 많이 없는것 같다. 왜 타입 에러가 나는지 정말 모르겠는 상황에 임시적인 에러 해결 방법 또는 어떤 타입이 들어와야 하는지 확실하게 알고 있는데 컴파일러 에러가 발생할 때 디버깅 용으로 사용하는 것이 좋다.실습 해보기Q1. 숫자와 문자가 섞여있는 배열을 숫자만 들어있는 배열로 클리닝하는 함수를 작성해보자.function Cleaning(array: (number | string)[]) { let Cleaned: number[] = []; array.forEach((elem) =&gt; { if (typeof elem === \"string\") { Cleaned.push(parseInt(elem)); } else { Cleaned.push(elem); } }); return Cleaned;}Q2. 선생님 object 자료를 파라미터로 전달하면 해당 선생님이 가르치고 있는 과목 중 맨 뒤의 1개를 반환하는 함수를 작성해보자.아래와 같은 선생님들이 있다고 가정하자.let 철수쌤 = { subject: \"math\" };let 영희쌤 = { subject: [\"science\", \"english\"] };let 민수쌤 = { subject: [\"science\", \"art\", \"korean\"] };function TeachingSubject(teacher: { subject: string | string[] }) { // subject 타입이 string일때 if (typeof teacher.subject === \"string\") { return teacher.subject; // subject 타입이 배열일때 } else if (Array.isArray(teacher.subject)) { return teacher.subject[teacher.subject.length - 1]; // 그 외의 타입일때 } else { return \"과목이 없습니다\"; }}" }, { "title": "Typescript 함수에 타입 지정하는 법", "url": "/posts/TS-%ED%95%A8%EC%88%98%EC%97%90-%ED%83%80%EC%9E%85-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0/", "categories": "Typescript", "tags": "", "date": "2022-05-08 17:13:00 +0900", "snippet": "기본적인 함수의 타입 지정 방법함수는 총 두 군데에 타입 지정이 가능하다. 함수로 들어오는 자료 (파라미터) 함수에서 나가는 자료 (return)function Test(x: number): number { return x * 2;}위와 같은 형태로 작성하며, 파라미터 x 옆에 있는 타입이 파라미터의 타입을 지정하는 부분이고, 함수명() 우측에 있는 타입이 return 값의 타입을 지정하는 부분이다.void 타입return할 값이 없는 경우 void 타입을 사용한다.이는 만약 함수가 뭔가를 반환하게 되면 오류를 발생시킨다.function Test(x: number): void { // return 없는 기능}타입 지정된 파라미터의 입력은 필수다그냥 자바스크립트는 파리미터를 받는 함수임에도 인자를 전달하지 않더라도 오류가 발생하지 않지만, 타입스크립트에서 타입 지정된 파라미터의 입력은 필수임에 주의해야한다.만약 파라미터가 옵션일 경우에는 아래처럼 ?를 사용한다.function Test(x?: number): void { // return 없는 기능}Test();? 연산자는 선택적으로 들어올수도 있다 라는 뜻이긴 한데 undefined랑 똑같음에 주의해야한다.따라서 x?: number와 x: number | undefined는 같은 뜻이다.Q. 아래 함수를 실행하면 왜 에러가 날까?function func(x: number | string): void { console.log(x + 3);}func(2);A. 타입스크립트에서는 변수의 타입이 union type인 경우 해당 파라미터의 타입이 아직 확실하지 않으므로 자료의 조작을 일단 금지하기 때문이다.마찬가지 이유로 아래 코드도function func(x?: number): number { console.log(x + 3);}func(2);? 연산자로 인해 x 파라미터는 옵션 파라미터가 되고, 이는 number | undefined 형태와 동일하므로 x라는 파라미터의 타입이 아직 확실하지 않기 때문에 에러가 발생한다.고로 조건문을 통해 파라미터의 타입을 미리 검사해 조건에 따라 어떠한 기능을 실행할지 엄격하게 짜는 습관이 필요하다.과제Q1. 이름을 파라미터로 입력하면 콘솔창에 “안녕하세요 OOO”을 출력하고 파라미터로 아무것도 입력되지 않으면 “이름이 없습니다.”를 출력하는 함수를 만들어보자.function NameCheck(name?: string): void { if (name) { console.log(\"안녕하세요 \" + name); } else { console.log(\"이름이 없습니다.\"); }}Q2. 함수에 숫자 또는 문자를 집어넣으면 자릿수를 세어 출력해주는 함수를 작성해보자.function CountDigit(input: string | number): number { let result = 0; if (typeof input === \"string\") { result = input.length; } else if (typeof input === \"number\") { result = input.toString().length; } return result;} 먼저 파라미터로 들어온 값이 문자인지 숫자인지 검사하기 위해 조건문을 걸었다. 들어온 값이 문자라면 length를 통해 그것의 길이를 세어 result 변수에 저장하도록 하였다. 들어온 값이 숫자라면 toString()을 통해 문자열로 바꾼다음 length를 통해 그것의 길이를 세어 result 변수에 저장하도록 하였다. 마지막으로 result 값(타입은 number)을 반환한다.Q3. 결혼 가능 확률을 알려주는 함수를 만들어보자. 함수의 파라미터로 월소득, 집보유여부, 매력점수를 입력할 수 있어야 한다. 월소득은 만원 당 1점, 집보유시 500점/미보유시 0점, 매력점수는 ‘상’일때만 100점으로 계산한다. 총 점수가 600점 이상인 경우 ‘결혼가능’을 반환한다. 그 외에는 아무것도 반환하지 않는다.function CanMarriage( money: number, house: boolean, charmScore: string): string { let totalScore: number = 0; let result: string = \"\"; totalScore += money; if (house === true) { totalScore += 500; } if (charmScore === \"상\") { totalScore += 100; } if (totalScore &gt;= 600) { result = \"결혼가능\"; } return result;}" }, { "title": "Typescript 타입을 미리 정하기 애매할 때", "url": "/posts/TS-union&any&unknown/", "categories": "Typescript", "tags": "", "date": "2022-05-07 11:44:00 +0900", "snippet": "해당 변수에 들어올 값이 A 타입일지 B 타입일지 애매할 때 사용할 수 있는 방법들이 있다.Union Type타입 2개 이상을 합친 새로운 타입을 만드는 것으로 해당 변수에는 A 혹은 B 타입이 들어올 수 있습니다. 라는 타입 정의를 할 수 있도록 해준다.let name: string | number = \"Lee\"; // string 타입nane = 100; // number 타입let name: (string | number)와 같이 소괄호를 쳐도 된다.array 혹은 object 자료를 만들 때 union type은 아래와 같이 허용할 타입을 소괄호로 묶어 사용한다.let array: (number | string)[] = [1, \"2\", 3];let object: { data: number | string } = { data: \"123\" };다만, 여기서 알면 좋은 점은 변수에 정의된 union type은 값 할당과 동시에 OR의 역할이 사라지는데, 배열이나 객체에 정의된 union type은 값이 할당되어도 OR의 역할이 유지된다.any typeany type은 모든 자료형을 허용해주는 타입이며 아래와 같이 사용한다.let name: any;name = 모든 자료형 가능다만, 이것은 타입스크립트의 의미가 사라지므로 타입 관련 버그나 나도 잡아주지 않는 타입 실드 해제 문법이다.let name: any;name = 100;name = {};// 실드를 완전히 해제하기 때문에 오류가 나지 않는다let testVar: string = name;따라서 코드를 위와 같이 작성했을 때 testVar 변수에 any type을 가진 name이란 값이 할당되었으므로 testVar 변수의 실드가 완전히 해제되어 오류가 발생하지 않는다. any는 타입 실드를 해제하므로 타입스크립트를 쓰는 이유를 없애기 때문에 비상시 변수 타입체크 해제기능 용도로 사용하자.unknown typeany의 용도와 같다. 모든 자료형을 허용해준다.let name: unknown;name = 모든 자료형 가능다만, 얘는 any보다 조금 더 안전하다고 할 수 있는데, 그 이유는 아래와 같은 코드를 사용했을 때, 아까 위에서 타입 실드가 적용된 다른 변수에 any를 사용한 변수를 할당했을 때는 오류가 발생하지 않았는데 이번에는 해당 변수에서 타입 오류가 발생하게 된다.let name: unknown;name = 100;name = {};// string만 사용가능하다는 오류가 발생한다.let testVar: string = name;타입스크립트의 엄격함let age: string | number;age + 1; // 오류!Q. 자바스크립트에서는 string 자료형에도 number 자료형에도 +1이 가능하다. 근데 왜 위 코드에서는 에러가 나는 것일까?A. 타입스크립트는 타입 엄격한것을 좋아한다! 따라서 string + 1, number + 1은 각각 허용하지만, string | number + 1은 허용하지 않는 것이다. _string number 이것도 하나의 새로운 타입임에 주의해야 한다._ 실습 해보기Q1. 다음 변수 4개에 타입을 지정해보자. age에는 숫자도 들어올 수 있다.let user = \"kim\";let age = undefined;let married = false;let userInfo = [user, age, married];내 풀이let user: string = \"kim\";let age: undefined | number = undefined;let married: boolean = false;let userInfo: (string | number | undefined | boolean)[] = [user, age, married];Q2. 타입 지정을 안했더니 아래 코드를 실행했을 때, 터미널에 에러가 발생한다. 에러가 발생하지 않게 school 이란 변수에 타입을 지정해보자.let school = { score: [100, 97, 84], teacher: \"Phil\", friend: \"John\",};school.score[4] = false;school.friend = [\"Lee\", school.teacher];내 풀이 기본적으로 score은 string[] 타입, teacher과 friend는 string 타입이다. school.score[4] = false; -&gt; boolean 타입을 추가해야 할 것 같다. school.friend = [“Lee”, school.teacher];-&gt; friend에 string[] 타입을 추가해야 할 것 같다. let school: { score: (number | boolean)[]; teacher: string; friend: string | string[];} = { score: [100, 97, 84], teacher: \"Phil\", friend: \"John\",};school.score[4] = false;school.friend = [\"Lee\", school.teacher];" }, { "title": "Typescript 기본 타입 정리", "url": "/posts/TS-%EA%B8%B0%EB%B3%B8-%ED%83%80%EC%9E%85-%EC%A0%95%EB%A6%AC/", "categories": "Typescript", "tags": "", "date": "2022-05-06 23:22:00 +0900", "snippet": "기본 변수 타입 지정let name: string = \"Lee\";let age: number = 24;let isLoad: boolean = false;array &amp; object 안의 자료 타입 지정// arraylet members: string[] = [\"Lee\", \"Park\"];// objectlet info: { name: string; age: number } = { name: \"Lee\", age: 24 };꼭 모든 변수에 타입 지정을 하지 않아도 된다모든 변수에 타입을 하나하나 지정하지 않아도 변수 생성시 타입스크립트가 타입을 자동으로 부여해준다.예를들어 아래 코드처럼let name = \"Lee\";let age = 24;이렇게만 작성해도 name 변수는 string, 나이 변수는 number 타입을 자동으로 갖게 된다. 따라서 무조건 만드는 변수마다 타입을 명시할 필요는 없다는 것이다.실습 해보기Q1. 가장 좋아하는 곡과 가수 이름을 변수에 object 자료형으로 담아보자. 다만, 제목과 가수에는 문자만 들어올 수 있어야 한다.let favInfo: { song: string; singer: string } = { song: \"라일락\", singer: \"IU\",};Q2. 다음과 같이 생긴 자료의 타입 지정을 해보자.let project = { member: [\"Kim\", \"Park\"], days: 30, started: true,};내 풀이let project: { member: string[]; days: number; started: boolean;} = { member: [\"Kim\", \"Park\"], days: 30, started: true,};" }, { "title": "자바스크립트의 forEach, map, filter, reduce", "url": "/posts/%EB%B3%B4%EC%B6%A9%ED%95%99%EC%8A%B5/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-05-05 22:26:00 +0900", "snippet": "1. forEach용도: for 반복문 대신 사용하는 친구 그러나 이 친구는 for문과 다르게 중간에 break를 걸 수 없다. 따라서 배열을 순회하는 경우 주로 사용한다.forEach 함수는 2개의 인자를 받게 구성되어 있으며 첫번째 인자는 함수를 받고, 두번째 인자는 콜백함수 내부에서 this로 사용되는 친구를 받는다.첫번째 인자(함수)는 무조건 넘겨줘야하며 두번쨰 인자는 생략 가능하다.a = [10, 11, 12, 13, 14, 15];a.forEach(function (v, i) { console.log(v, i);});// 10 0// 11 1// 12 2// 13 3// 14 4// 15 5a.forEach( function (v, i) { console.log(v, i, this); }, // 첫번째 인자(=함수) [1, 2] // 두번째 인자);// 10 0 (2) [1, 2]// 11 1 (2) [1, 2]// 12 2 (2) [1, 2]// 13 3 (2) [1, 2]// 14 4 (2) [1, 2]// 15 5 (2) [1, 2](위의 콜백 함수에서 v는 값이고 i는 인덱스)그렇다면 forEach 함수는 어떻게 구현되어 있을까? (정석X)function forEach(predicate, thisArg) { for (let i = 0; i &lt; a.length; i++) { predicate(a[i], i); }}내부 로직은 이런식으로 되어있을것 같다. [정리] forEach는 배열 요소를 하나하나 탐색하면서 탐색을 할때마다 콜백 함수를 반복 호출한다.2. mapmap도 마찬가지로 중간에 break문을 사용할 수 없다.map은 실행 결과를 모은 새로운 배열을 반환하기 때문에 map의 용도를 제대로 사용하려면 return 문이 있어야 한다.a = [10, 11, 12, 13, 14, 15];let answer = a.map( function (v, i) { return v * v; }, // 첫번째 인자(=함수) [1, 2] // 두번째 인자);console.log(answer);// (6) [100, 121, 144, 169, 196, 225]주의할점그렇다면 안에 if 조건을 걸어 조건에 해당하는 값만 반환하도록 설정하면결과를 가지고 만들어낸 새로운 배열의 값은 어떻게 구성되어 있을까?a = [10, 11, 12, 13, 14, 15];let answer = a.map( function (v, i) { if (v % 2 == 0) return v; }, // 첫번째 인자(=함수) [1, 2] // 두번째 인자);console.log(answer);// (6) [10, undefined, 12, undefined, 14, undefined] 생성된 새로운 배열은 항상 원본 배열의 길이와 동일하기 때문에 위의 코드에서 짝수인 10, 12, 14만 반환될거라는 생각은 틀림에 주의해야 한다.그렇다면 map 함수는 어떤식으로 구현되어 있을까? (정석X)function map(predicate, thisArg) { let list = []; for (let i = 0; i &lt; a.length; i++) { list.push(predicate(a[i], i)); } return list;}내부 로직은 이런식으로 되어있을것 같다. [정리] 배열의 각 요소에 대해 콜백을 실행하고 실행 결과를 모은 새 배열을 반환한다.3. filtera = [10, 11, 12, 13, 14, 15];let answer = a.filter( function (v, i) { return v % 2 == 0; }, // 첫번째 인자(=함수) [1, 2] // 두번째 인자);console.log(answer);// (3) [10, 12, 14] map처럼 새로운 배열을 생성해 반환하는데, 원본 배열의 길이와 동일할 필요가 없이 정확하게 원하는 원소만 새로운 배열에 넣어 반환한다.그렇다면 filter 함수는 어떤식으로 구현되어 있을까? (정석X)function map(predicate, thisArg) { let list = []; for (let i = 0; i &lt; a.length; i++) { if (predicate(a[i], i)) list.push(a[i]); } return list;}내부 로직은 이런식으로 되어있을것 같다.4. reducea = [10, 11, 12, 13, 14, 15];let answer = a.reduce( function (acc, v) { return acc + v; }, // 첫번째 인자(=함수) 0 // 두번째 인자);console.log(answer);// 75// 10+11+12+13+14+15(위의 코드는 배열 원소들의 전체 합을 구하는 코드) 배열의 각 요소에 대해 콜백을 실행해 단 1개의 출력 결과를 만든다.그렇다면 reduce 함수는 어떤식으로 구현되어 있을까? (정석X)function reduce(predicate, value) { let result = value; // 두번째 인자가 넘어감(위의 코드상 0) for (let i = 0; i &lt; a.length; i++) { result = predicate(result, a[i]); // predicate(0, 10)... } return result;}내부 로직은 이런식으로 되어있을것 같다.reduce 함수는 위의 예시처럼 배열 원소들의 전체 합을 구하거나 배열을 펼치거나 배열 원소의 개수 등을 셀 때 혹은 배열을 딕셔너리로 변경할때 사용하기도 한다." }, { "title": "일곱난쟁이", "url": "/posts/%EC%9D%BC%EA%B3%B1%EB%82%9C%EC%9F%81%EC%9D%B4/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-05-04 23:36:00 +0900", "snippet": "문제왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다. 아홉 명의 난쟁이는 모두 자신이 “백설 공주와 일곱 난쟁이”의 주인공이라고 주장했다. 뛰어난수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.▣ 입력설명아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.▣ 출력설명입력된 순서대로 일곱 난쟁이의 키를 출력한다.▣ 입력예제 120 7 23 19 10 15 25 8 13▣ 출력예제 120 7 23 19 10 8 13내가 생각한 풀이function solution(arr) { let answer = arr; // answer과 arr은 같은 주소를 가리키고 있기 때문에 arr 수정하면 answer도 수정됨(=얕은복사) let sum = answer.reduce((acc, v) =&gt; acc + v, 0); // 140 for (let i = 0; i &lt; answer.length - 1; i++) { for (let j = i + 1; j &lt; answer.length; j++) { if (sum - (answer[i] + answer[j]) === 100) { answer.splice(j, 1); answer.splice(i, 1); } } } return answer;}let arr = [20, 7, 23, 19, 10, 15, 25, 8, 13];console.log(solution(arr));let arr = [20, 7, 23, 19, 10, 15, 25, 8, 13]; 이렇게 있으면 (20, 7), (20, 23), (20, 19)… (25, 13), (8, 13) 까지 2개씩 짝지어 arr 배열의 원소를 다 더한 값인 140(sum)에서 뺄셈을 해 그 결과값이 100이 되면 가짜 난쟁이이므로 splice()를 이용해 제거한다.splice는 배열의 기존 요소를 삭제 또는 교체하거나 새 요소를 추가하여 배열의 내용을 변경하는 메소드이다.그리고if (sum - (answer[i] + answer[j]) === 100) { answer.splice(j, 1); answer.splice(i, 1);}이 부분에서 answer.splice(i, 1); 다음에 answer.splice(j, 1); 순으로 작성하지 않은 이유는 만약 i 먼저 삭제하고 j를 삭제한다면 i가 삭제되는 순간 j의 인덱스가 앞으로 한칸 당겨져서 오기 때문에 이상한 값이 삭제되기 때문이다. 따라서 뒤에 존재하는 j부터 먼저 삭제하고 i를 삭제하는 순으로 실행해줘야 한다." }, { "title": "10부제", "url": "/posts/10%EB%B6%80%EC%A0%9C/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-05-03 22:00:00 +0900", "snippet": "문제서울시는 6월 1일부터 교통 혼잡을 막기 위해서 자동차 10부제를 시행한다. 자동차 10부제는자동차 번호의 일의 자리 숫자와 날짜의 일의 자리 숫자가 일치하면 해당 자동차의 운행을 금지하는 것이다. 예를 들어, 자동차 번호의 일의 자리 숫자가 7이면 7일, 17일, 27일에 운행하지 못한다. 또한, 자동차 번호의 일의 자리 숫자가 0이면 10일, 20일, 30일에 운행하지 못한다.여러분들은 일일 경찰관이 되어 10부제를 위반하는 자동차의 대수를 세는 봉사활동을 하려고한다. 날짜의 일의 자리 숫자가 주어지고 7대의 자동차 번호의 끝 두 자리 수가 주어졌을 때위반하는 자동차의 대수를 출력하는 프로그램을 작성하세요.▣ 입력설명첫 줄에는 날짜의 일의 자리 숫자가 주어지고 두 번째 줄에는 7대의 자동차 번호의 끝 두 자리 숫자가 주어진다.▣ 출력설명주어진 날짜와 자동차의 일의 자리 숫자를 보고 10부제를 위반하는 차량의 대수를 출력합니다.▣ 입력예제 1325 23 11 47 53 17 33▣ 출력예제 13▣ 입력예제 2012 20 54 30 87 91 30▣ 출력예제 23내가 생각한 풀이법function solution(day, arr) { let answer = 0; for (let i of arr) { if (i % 10 === day) answer++; } return answer;}arr = [25, 23, 11, 47, 53, 17, 33];console.log(solution(3, arr));‘n의 자리만 필요하다’라는 뉘앙스가 있으면 나머지 연산을 생각해보자." }, { "title": "홀수", "url": "/posts/%ED%99%80%EC%88%98/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-05-02 13:55:00 +0900", "snippet": "문제7개의 자연수가 주어질 때, 이들 중 홀수인 자연수들을 모두 골라 그 합을 구하고, 고른 홀수들 중 최소값을 찾는 프로그램을 작성하세요. 예를 들어, 7개의 자연수 12, 77, 38, 41, 53, 92, 85가 주어지면 이들 중 홀수는 77, 41, 53, 85이므로 그 합은 77 + 41 + 53 + 85 = 256 이 되고, 41 &lt; 53 &lt; 77 &lt; 85 이므로 홀수들 중 최소값은 41이 된다.▣ 입력설명첫 번째 줄에 자연수 7개가 주어진다. 주어지는 자연수는 100보다 작다. 홀수가 한 개 이상 반드시 존재한다.▣ 출력설명첫째 줄에 홀수들의 합을 출력하고, 둘째 줄에 홀수들 중 최소값을 출력한다.▣ 입력예제 112 77 38 41 53 92 85▣ 출력예제 125641내가 생각한 풀이법function solution(arr) { let answer = []; let oddNum = []; let sum = 0; let min = Number.MAX_SAFE_INTEGER; for (let i = 0; i &lt; arr.length; i++) { if (arr[i] % 2 === 1) oddNum.push(arr[i]); } for (let i = 0; i &lt; oddNum.length; i++) { if (oddNum[i] &lt; min) min = oddNum[i]; sum += oddNum[i]; } answer.push(sum); answer.push(min); return answer;}arr = [12, 77, 38, 41, 53, 92, 85];console.log(solution(arr));다른 풀이법function solution(arr) { let answer = []; let sum = 0, min = Number.MAX_SAFE_INTEGER; for (let x of arr) { if (x % 2 === 1) { sum += x; if (x &lt; min) min = x; } } answer.push(sum); answer.push(min); return answer;}arr = [12, 77, 38, 41, 53, 92, 85];console.log(solution(arr));일단 내가 스스로 짠 코드는 아직 자바스크립트 문법을 잘 모르는 상태에서 짜서 그런가 선언한 변수도 많고 반복문도 정석으로 돌린 코드였다. 하지만 답안의 반복문을 보면 let i = 0; i &lt; arr.length; i++ 가 아닌 let x of arr라고 되어있다. 자바스크립트에서 이런 식으로도 반복문을 사용할 수 있구나라는 것이 이번 문제를 통해 알게 된 첫번째로 알게 된 부분이다.그리고 두번째로 알게 된 부분은 한 함수 안에서 어떻게 여러 값을 return 하는가? 였는데 일단 자바스크립트에서는 answer라는 배열을 만들어 그 안에answer.push(sum);answer.push(min);return answer;와 같은 형태로 return할 값을 push 해준후 return answer를 실행하면 된다.즉, return명령은 함수에서 값을 반환하지만 복수의 값을 반환할 수는 없다. 따라서 `배열과 객체를 이용해 복수의 값을 반환하게 할 수 있다. 쉽게 말하면 위에 설명한 방법처럼 여러값들을 배열 혹은 객체로 묶어서 하나의 값으로 만든다음에 반환시키는 방법이다.그런데 위와 같이 코드를 짠 후 실행시켜보면 아래와 같은 배열의 형태로 결과가 출력된다.(2) [256, 41]그런데 해당 문제에서 원하는 것은 첫번째 줄에 홀수들의 합을 출력하고 두번째 줄에 홀수중에 가장 작은 값을 출력하는 것이므로 배열 형태가 아닌 두 줄의 형태로 출력해줘야 했다.따라서 구조 분해 할당을 이용해 결과값을 두 줄로 출력해야한다.구조 분해 할당을 이용해 결과값을 두 줄로 출력한 코드function solution(arr) { let sum = 0; let min = Number.MAX_SAFE_INTEGER; for (let x of arr) { if (x % 2 === 1) { sum += x; if (x &lt; min) min = x; } } return [sum, min]; // 1}arr = [12, 77, 38, 41, 53, 92, 85];let [resultSum, resultMin] = solution(arr); // 2console.log(resultSum); // 3console.log(resultMin); // 4 배열 형식으로 return 한다. resultSum에는 solution() 함수를 실행하고 반환한 배열의 첫번째 값인 sum을 resultMin에는 두번째 값인 min을 할당한다. 2에서 수행한 resultNum 값을 출력한다. 2에서 수행한 resultMin 값을 출력한다.이렇게 코드를 작성한 후 결과값을 보면25641이처럼 결과값이 두 줄로 출력된다.근데 사실 구조분해할당이고 뭐고 정답 출력할 때 그냥 이렇게 작성해도 되긴 된다.for (let i of solution(arr)) { console.log(i);}※ 배운것: 새로운 for문 형식, 복수 값 return, 구조분해할당" }, { "title": "1부터 N까지의 합 & 최소값 구하기", "url": "/posts/1%EB%B6%80%ED%84%B0-N%EA%B9%8C%EC%A7%80%EC%9D%98-%ED%95%A9&%EC%B5%9C%EC%86%8C%EA%B0%92-%EA%B5%AC%ED%95%98%EA%B8%B0/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-05-01 13:30:00 +0900", "snippet": "1부터 N까지의 합문제자연수 N이 입력되면 1부터 N까지의 합을 출력하는 프로그램을 작성하세요.▣ 입력설명첫 번째 줄에 20이하의 자연수 N이 입력된다.▣ 출력설명첫 번째 줄에 1부터 N까지의 합을 출력한다.▣ 입력예제 16▣ 출력예제 121▣ 입력예제 210▣ 출력예제 255딱히 중요한건 없고 반복문을 이용해 sum 변수에 누적합을 넣는다.function solution(n) { let sum = 0; for (let i = 1; i &lt;= n; i++) { sum += i; } return sum;}console.log(solution(10));최소값 구하기문제7개의 수가 주어지면 그 숫자 중 가장 작은 수를 출력하는 프로그램을 작성하세요.▣ 입력설명첫 번째 줄에 7개의 수가 주어진다.▣ 출력설명첫 번째 줄에 가장 작은 값을 출력한다.▣ 입력예제 15 3 7 11 2 15 17▣ 출력예제 12Number.MAX_SAFE_INTEGER 는 JavaScript에서 안전한 최대 정수값을 나타낸다.보통 알고리즘 문제를 풀 때 변수값을 매개변수로 들어오는 값으로 초기화해놓고 비교를 했었는데 Number.MAX_SAFE_INTEGER를 이용해 들어올 수 있는 가장 큰 값을 넣어놓고, 최솟값 비교를 할 수 있도록 한다.Number.MAX_SAFE_INTEGER를 사용하는 이유는 정수를 정확하고 올바르게 비교할 수 있는 안전함을 가지고 있기 때문이라고 한다.function solution(arr) { let answer, // 이렇게 최소값을 가장 큰 값으로 미리 지정 min = Number.MAX_SAFE_INTEGER; for (let i = 0; i &lt; arr.length; i++) { if (arr[i] &lt; min) min = arr[i]; } answer = min; return answer;}let arr = [5, 7, 1, 3, 2, 9, 11];console.log(solution(arr));내장 함수로 최대/최소 구하는 방법 Math.min() Math.max()이용하기function solution() { let answer = Math.min(3, 2, 7, 9, 1); // 2 return answer;}주의할점Math.min()의 인자로 배열 객체 자체를 넘기면 값을 구해주지 않음 따라서 전개 연산자 …를 이용해 배열을 펼쳐서 넘겨줘야 한다.function solution(arr) { let answer = Math.min(...arr); // 전개 연산자 사용 return answer;}let arr = [5, 7, 1, 3, 2, 9, 11];console.log(solution(arr)); // 1전개 연산자를 안쓰고 하는법도 있긴함. let answer = Math.min.apply(null, arr);" }, { "title": "연필 개수", "url": "/posts/%EC%97%B0%ED%95%84-%EA%B0%9C%EC%88%98/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-04-30 11:45:00 +0900", "snippet": "문제연필 1 다스는 12자루입니다. 학생 1인당 연필을 1자루씩 나누어 준다고 할 때 N명이 학생수를 입력하면 필요한 연필의 다스 수를 계산하는 프로그램을 작성하세요.▣ 입력설명첫 번째 줄에 1000 이하의 자연수 N이 입력된다.▣ 출력설명첫 번째 줄에 필요한 다스 수를 출력합니다.▣ 입력예제 125▣ 출력예제 13▣ 입력예제 2178▣ 출력예제 215자바스크립트의 함수중 입력받은 값을 올림해주는 함수를 사용했다. Math.round(): 반올림 Math.ceil(): 올림 Math.floor(): 내림자바스크립트에서는 부동소수점을 표현하는 방법에 한계가 있어 실수의 경우 정밀한 숫자를 표현하는데 한계(오차)가 있다. 이러한 오차는 Number.EPSILON이란 상수를 사용해 기존 값에 이 상수를 더해 오차를 많이 줄어들게끔 보정해줄수는 있지만, 이는 충분하다고는 할 수 없으므로 정밀한 숫자 계산은 Front-End 에서보다는 Back-End 측에서 계산해주는 것이 더 좋을것 같다!내가 생각한 풀이법function solution(n) { let answer = Math.ceil(n / 12); return answer;}console.log(solution(178));" }, { "title": "Typescript 컴파일 옵션 설정하기", "url": "/posts/TS-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%8B%9C-%EC%84%A4%EC%A0%95/", "categories": "Typescript", "tags": "Typescript", "date": "2022-04-29 12:32:00 +0900", "snippet": "📌 tsconfig.json 파일 생성하기이곳에는 타입스크립트인 .ts 파일들을 .js 파일로 변환할 때 어떻게 변환할 것인지에 대한 세부 설정이 가능하다.(리액트나 뷰를 쓰는 중이면 이미 파일이 있을 수 있다.)파일을 만들었으면 아래와 같은 코드를 작성해준다.{ \"compilerOptions\": { \"target\": \"es5\", \"module\": \"commonjs\", \"sourceMap\": true }, \"include\": [\"index.ts\"], \"exclude\": [\"node_modules\"]} target: 타입스크립트 파일을 어떤 버전의 자바스크립트로 바꿔줄지 명시하는 부분 es5: es5 버전의 자바스크립트로 컴파일 해줌. 신버전을 원하면 es2016, esnext와 같은것 입력하자. module: 자바스크립트 파일간 import 문법을 구현할 때 어떤 문법을 쓸지 정하는 부분 commonjs: require 문법 es2015, esnext: import 문법 IE와의 어느정도 호환성을 원하면 es5, commonjs 국룰 sourceMap: sourceMap 처리를 하고 싶은지 여부 include: 어떤 파일들이 컴파일 과정에 포함되는지 명시하는 부분 exclude: 컴파일 과정에서 배제할 파일 명시하는 부분추가로 넣을만한 옵션들에는 아래와 같은 것들이 있다.{ \"compilerOptions\": { \"noImplicitAny\": true, \"strictNullChecks\": true }} noImplicitAny: any 라는 타입이 의도치않게 발생할 경우 에러를 띄워주는 설정 strictNullChecks: null, undefined 타입에 이상한 조작을 하면 ㄷ에러를 띄워주는 설정아래는 그나마 쓸모있어보이는 옵션들만 추려본 것!{ \"compilerOptions\": { \"target\": \"es5\", // 'es3', 'es5', 'es2015', 'es2016', 'es2017','es2018', 'esnext' 가능 \"module\": \"commonjs\", //무슨 import 문법 쓸건지 'commonjs', 'amd', 'es2015', 'esnext' \"allowJs\": true, // js 파일들 ts에서 import해서 쓸 수 있는지 \"checkJs\": true, // 일반 js 파일에서도 에러체크 여부 \"jsx\": \"preserve\", // tsx 파일을 jsx로 어떻게 컴파일할 것인지 'preserve', 'react-native', 'react' \"declaration\": true, //컴파일시 .d.ts 파일도 자동으로 함께생성 (현재쓰는 모든 타입이 정의된 파일) \"outFile\": \"./\", //모든 ts파일을 js파일 하나로 컴파일해줌 (module이 none, amd, system일 때만 가능) \"outDir\": \"./\", //js파일 아웃풋 경로바꾸기 \"rootDir\": \"./\", //루트경로 바꾸기 (js 파일 아웃풋 경로에 영향줌) \"removeComments\": true, //컴파일시 주석제거 \"strict\": true, //strict 관련, noimplicit 어쩌구 관련 모드 전부 켜기 \"noImplicitAny\": true, //any타입 금지 여부 \"strictNullChecks\": true, //null, undefined 타입에 이상한 짓 할시 에러내기 \"strictFunctionTypes\": true, //함수파라미터 타입체크 강하게 \"strictPropertyInitialization\": true, //class constructor 작성시 타입체크 강하게 \"noImplicitThis\": true, //this 키워드가 any 타입일 경우 에러내기 \"alwaysStrict\": true, //자바스크립트 \"use strict\" 모드 켜기 \"noUnusedLocals\": true, //쓰지않는 지역변수 있으면 에러내기 \"noUnusedParameters\": true, //쓰지않는 파라미터 있으면 에러내기 \"noImplicitReturns\": true, //함수에서 return 빼먹으면 에러내기 \"noFallthroughCasesInSwitch\": true, //switch문 이상하면 에러내기 }}https://www.typescriptlang.org/tsconfig 이곳에 들어가면 더 많은 옵션들을 살펴볼 수 있음." }, { "title": "Typescript 설치와 필수 문법", "url": "/posts/TS-%EC%84%A4%EC%B9%98%EC%99%80-%ED%95%84%EC%88%98-%EB%AC%B8%EB%B2%95/", "categories": "Typescript", "tags": "Typescript", "date": "2022-04-28 16:01:00 +0900", "snippet": "이하 Typescript 관련 정보는 “코딩애플”에서 Typescript 강의를 들으며 공부한 내용을 정리한 것입니다.📌 Typescript 설치하기Typescript는 타입에 관대한 자바스크립트를 조금 더 엄격하게 만들어주는 것이다.이미 만든 React 프로젝트에서 Typescript 사용하기 npm install typescript @types/node @types/react @types/react-dom @types/jest처음부터 Typescript 사용하기 npx create-react-app 프로젝트명 –template typescripttemplate 앞에 작대기 2개임에 주의!!일반 HTML, CSS, JS로 생성한 프로젝트 혹은 Vue에서도 타입스크립트를 사용할 수 있다.📌 필수 문법 살펴보기변수 타입 지정하기let name: string = \"Lee\";변수를 만들 때 타입 지정이 가능하다.변수명: 타입명 이런 형태로 작성한다.타입명에는 string, number, boolean, bigint, null, undefined, [], {} 등이 가능하다!let name: string = \"Lee\";name = 123;위와 같이 string 타입을 지정해두었는데 해당 타입과 일치하지 않는 타입으로 의도치 않게 변경될 경우 에러를 발생시킨다.배열 &amp; 객체 타입 지정하기let name: string[] = [\"Lee\", \"Kim\"];let age: { age: number } = { age: number };array와 object 자료는 이렇게 타입 지정이 가능하다.여러 타입 지정하기let name: string | number = \"Lee\";지정한 변수에 여러가지 타입의 데이터가 들어오는 경우 OR 연산자(|)를 이용해 표현하면 된다.위와 같은 경우는 name 변수에 문자 혹은 숫자를 넣을 수 있게 된다.사용할 타입을 미리 변수로 만들어두기type nameType = string | number;let name: nameType = \"Lee\";이런식으로 type 키워드를 이용해 사용할 타입을 미리 변수처럼 담아두고 필요한 곳에서 사용할 수 있다.나만의 타입 만들기type myType = \"Lee\" | \"Kim\";let name: myType = \"Kim\";나만의 타입을 만들어 사용할 수도 있다.type 키워드에 원하는 글자나 숫자를 입력해두고 필요한 곳에서 만들어둔 타입 변수를 꺼내 사용하면 앞으로 해당 변수에서는 내가 지정한 값만 들어올 수 있다. 즉 여기서는 name에 ‘Lee’ 혹은 ‘Kim’만 들어올 수 있다. literal type 이라 부른다.함수에 타입 지정하기function TestFnc(x: number): number { return x * 2;}함수에 사용하는 경우 파라미터와 반환값이 어떤 타입이여야 하는지 지정이 가능하다. 실수로 다른 타입이 들어오거나 나가는 경우 에러를 발생시킨다. (x: number) =&gt; 파라미터 타입 지정 : number =&gt; return 타입 지정return 타입으로 void 설정이 가능한데 이는 return이 없는지 체크할 수 있는 타입이다.주의할 점타입스크립트는 타입이 애매한것을 좋아하지 않기 때문에 narrowing 혹은 assertion 문법을 사용해 코드를 짜야 정상적으로 사용이 가능하다.즉 이게 무슨 말인가 하면, 위의 코드처럼 짜면 안되고 아래 코드처럼 짜야한다는 말이다.// narrowingfunction TestFnc(x: number | string) { if (typeof x === \"number\") { return x * 2; } else if (typeof x === \"string\") { return x + 1; } else { return 0; }}// assertionfunction TestFnc(x: number | string) { return (x as number) + 1;}배열에 사용할 수 있는 튜플 타입type Member = [number, boolean];let jihyun: Member = [100, false];array에 쓸수 있는 tuple 타입이제 jihyun에는 Member이란 타입이 지정되었기 때문에 number과 boolean값이 순서대로 들어와야 한다. 만약 다른 값이 들어오면 에러를 발생시킨다.index signature과 물음표type myObject = { // 문자로 된 모든 object 속성의 타입은 string으로 지정 [key: string]: string; // 특정 속성이 선택사항이면 물음표를 적는다. name?: string; age: number;};let jihyun: myObject = { name: \"Lee\", age: 24, //[key: string]: string; 때문에 에러 발생안함 age: \"24\",};object 타입도 정의가 너무 많으면 type 키워드로 변수에 담아 사용 가능하다.(interface 키워드로도 사용 가능)특정 속성이 선택사항이면 물음표를 적으면 된다.object 안에 어떤 속성이 들어갈지 아직 모른다면 [key: string]: string; 와 같은 index signature를 이용할 수 있다.class 타입 지정하기class Person { name; constructor(name: string) { this.name = name; }}이런식으로 class도 타입 설정이 가능한데, 사용할 변수를 중괄호 내에 미리 만들어놔야 constructor 안에서 this.name 이런식으로 사용이 가능하다." }, { "title": "삼각형 판별하기", "url": "/posts/%EC%82%BC%EA%B0%81%ED%98%95-%ED%8C%90%EB%B3%84%ED%95%98%EA%B8%B0/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-04-27 16:41:00 +0900", "snippet": "문제길이가 서로 다른 A, B, C 세 개의 막대 길이가 주어지면 이 세 막대로 삼각형을 만들 수 있으면 “YES”를 출력하고, 만들 수 없으면 ”NO”를 출력한다.▣ 입력설명첫 번째 줄에 100이하의 서로 다른 A, B, C 막대의 길이가주어진다.▣ 출력설명첫 번째 줄에 “YES”, “NO”를 출력한다.▣ 입력예제 16 7 11▣ 출력예제 1YES▣ 입력예제 113 33 17▣ 출력예제 1NO정석은 3개의 변의 길이 중에 첫번째로 짧은 변의 길이와 두번째로 짧은 변의 길이의 합이 가장 긴 변의 길이보다 길어야 한다는 것을 전제로 문제를 풀이하는 것이다. 나는 삼각형의 두 변의 길이의 합은 나머지 한 변의 길이보다 크다라는 것을 전제로 if 문을 이용해 모든 경우를 검사해서 풀이하였다.내가 생각한 풀이법function solution(a, b, c) { let answer; if (a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a) { answer = \"YES\"; } else answer = \"NO\"; return answer;}console.log(solution(13, 33, 17));" }, { "title": "세 수 중 최소값 구하기", "url": "/posts/%EC%84%B8-%EC%88%98-%EC%A4%91-%EC%B5%9C%EC%86%8C%EA%B0%92-%EA%B5%AC%ED%95%98%EA%B8%B0/", "categories": "Algorithm, with Javascript", "tags": "", "date": "2022-04-26 19:48:00 +0900", "snippet": "문제100이하의 자연수 A, B, C를 입력받아 세 수 중 가장 작은 값을 출력하는 프로그램을 작성하세요.(정렬을 사용하면 안됩니다)▣ 입력설명첫 번째 줄에 100이하의 세 자연수가 입력된다.▣ 출력설명첫 번째 줄에 가장 작은 수를 출력한다.▣ 입력예제 16 5 11▣ 출력예제 15나는 a, b, c를 모두 각각 비교해 주었는데 if/else문 한개로 먼저 a와 b를 비교해 그 중 작은 수를 answer에 넣고 마지막에 if문 하나로 answer에 들어있는 값(a 혹은 b겠지)과 c를 비교해주면 더욱 짧은 코드로 작성이 가능했다. 즉, 하나씩 모두 비교할 필요 없이 두 수를 먼저 비교해서 answer 변수에 저장해두고 남은 수와 answer를 비교하면 된다.내가 생각한 풀이법function solution(a, b, c) { let answer; if (a &lt; b &amp;&amp; a &lt; c) { answer = a; } else if (b &lt; a &amp;&amp; b &lt; c) { answer = b; } else if (c &lt; a &amp;&amp; c &lt; b) { answer = c; } return answer;}console.log(solution(6, 5, 11));코드 길이를 조금 더 축약 가능한 풀이법function solution(a, b, c) { let answer; if (a &lt; b) answer = a; else answer = b; if (answer &gt; c) answer = c; return answer;}console.log(solution(6, 5, 11));" }, { "title": "SASS / SCSS", "url": "/posts/SASS&SCSS/", "categories": "HTML & CSS, css", "tags": "", "date": "2022-04-25 20:23:00 +0900", "snippet": "SASS반복되는 CSS 부분을 쉽게 처리할 수 있도록 프로그래밍스러운 문법을 사용할수 있게 도와준다.웹브라우저는 .css만 읽을 수 있고 .scss는 읽을수 없다.따라서 scss -&gt; css 변환을 해줘야 사용이 가능하다.변환은 VSCODE 사용시 live sass compiler라는 것을 설치하면 가능하다.(v.5.0.0 이상)위의 확장팩을 설치했으면 VSCODE 아래 메뉴 바에 Watch Sass라는 것을 눌러주면 알아서 변환해준다.이제 코드는 scss에 짜고 html에 넣을 때는 css파일을 넣으면 된다.어 근데 왜 SASS 설명이라고 해놓고 파일 확장자는 .scss 인가요?.sass 파일로 생성해도 된다. 그러나 sass 파일에 스타일을 작성할때는 { }와 같은 것들을 쓰지 않아도 된다! // scss .background { color: red; } // sass .background color: red&lt;정리&gt;1. 작성할 .html 파일과 .scss 파일 생성2. scss -&gt; css 변환해줄 컴파일러 같은거 설치 후 실행3. VSCODE의 경우 위의 과정을 실행하면 .css/.css.map 파일이 생성됨4. 여기서 .scss 파일에 나의 코드를 직접 작성하고5. .html 파일에는 3)에서 생성된 .css 파일을 연결해주면 된다.※ 무작정 sass로 먼저 작성해야지! 라는 마인드보다는 일단 기본 css로 작성하고 겹치는 부분이 많이 보이면 그것들을 모아서 축약해주는것이 헷갈리지 않고 좋다.SASS의 용도 어려운 단어를 기억해야할 때 변수 문법을 사용하게 해준다. 규칙적인 스타일을 생성해야 할 때 도움을 준다.$메인색상: #2a4cb2;$기본크기: 16px;.background { background-color: $메인색상; font-size: $기본크기 - 2px;}.container { font-size: ($기본크기 * 2px);}nesting 문법// 기본 문법.main-background h4 { font-size: 16px;}.main-background button { color: red;}// nesting 문법.main-background { h4 { font-size: 16px; } button { color: red; }}nesting 문법을 사용하면 관련있는 class 들을 묶을 때 용이하다. 따라서 UI들을 뭉쳐서 관리하고 싶을때 사용한다.@extend 문법빨강, 파랑, 초록의 3가지 색의 버튼이 필요하다고 가정해보자.그러면 보통 아래와 같이 코드를 작성할텐데 이러면 중복된 부분(여기서는 width, height, padding)이 많다..btn-red { width: 100px; height: 100px; padding: 20px; color: red;}.btn-blue { width: 100px; height: 100px; padding: 20px; color: blue;}.btn-green { width: 100px; height: 100px; padding: 20px; color: green;}이러한 중복을 없애려면 이전에 뼈와 살을 분리하면 편리하다고 배웠다. 하지만 이전에 배운 내용은 익숙하지 않다면 한번에 알아보기 불편했고(개인적인 의견) React와 같은 것들을 주로 사용하는 요즘에는 그닥 유용하지 않다고 생각하므로 @extend 문법을 사용하면 조금 더 직관적으로 중복을 없앨수 있다.&lt;방법&gt; 중복이 발생하는 코드를 잘라내 변수에 포함한다.// ⓐ 중복 속성들을 요렇게 변수로 저장%btn { width: 100px; height: 100px; padding: 20px;}.btn-red { // ⓑ 요렇게 @extend를 이용해 명시 @extend %btn; color: red;}.btn-blue { @extend %btn; color: blue;}.btn-green { @extend %btn; color: green;}다만, %변수명으로 저장해두는 임시클래스는 단독으로는 컴파일되지 않음에 주의해야 한다.@mixin 문법아래와 같은 font-size만 다른 코드가 있다고 가정하자.h2 { font-size: 30px; letter-spacing: -1px;}h3 { font-size: 20px; letter-spacing: -1px;}h4 { font-size: 10px; letter-spacing: -1px;}위에서 배운 @extend를 사용해 공통된 것들을 묶어두면 되긴 하지만, 이번에는 @mixin을 사용해보자. @mixin 문법은 긴 코드를 짧은 단어 하나로 축약할 때 사용한다.@mixin 폰트디자인() { font-size: 30px; letter-spacing: -1px;}h2 { @include 폰트디자인();}h3 { @include 폰트디자인();}h4 { @include 폰트디자인();}하지만 이렇게 작성하면 의도한것은 h3는 20px, h4는 10px 인데 h2나 h3나 h4의 모든 font-size가 30px로 고정되게 된다.따라서 $파라미터를 이용해 @mixin 문법을 가변적이게 해줄 수 있다.@mixin h태그디자인($폰트, $자간) { font-size: $구멍; letter-spacing: $자간;}h2 { @include h태그디자인(30px, -1px);}h3 { @include h태그디자인(20px, 1px);}h4 { @include h태그디자인(10px, 2px);}글자 중간에 $변수나 $파라미터를 넣을때는 #{$변수명}을 사용한다.@mixin h태그디자인($폰트, $자간) { font-size: $구멍; #{ $자간 }: 1px;}h2 { @include h태그디자인(30px, letter-spacing);}h3 { @include h태그디자인(20px, width);}h4 { @include h태그디자인(10px, padding);}@use 문법다른 파일에 있는 내용을 가져오고 싶을 때 사용한다.@use \"가져오고싶은 파일명\";다른 파일의 @mixin, $변수와 같은 것들도 가져올수 있다. 다른 파일의 $변수를 사용하려면 파일명.$변수를 사용한다. 다른 파일의 @mixin을 사용하려면 @include 파일명.mixin이름을 사용한다. [추가 팁]reset.scss와 같이 .css 파일로 변환해줄 필요가 없는 파일들은 파일명을 작명할때 언더바(_)를 붙여준다. 이러면 .css 파일로 변환하지 말아달라는 의미를 가지게 된다. (ex. _reset.scss)[궁금했던 점]Q. 전에 어디서 @import를 사용하는 것을 봤는데 이번에 배울때는 @use만을 배웠다. 왜 @import를 사용하지 않는걸까?A. 스타일시트 A에 B가 @import로 포함된 경우 첫번째 스타일시트가 다운로드 되기 전까지 다음 스타일시트의 다운로드가 시작되지 않을 가능성이 있기 때문이다.Sass로 축약하는 연습 해보기SASS 실습(1) - 리스트 만들기조건1) &lt;li&gt; 태그에 acitve라는 클래스가 부여되면 배경이 파란색으로 변해야함조건2) nesting 문법을 이용작성한 코드.main-list { li { list-style: none; padding: 15px; border: 1px solid lightgrey; // li태그 요소를 클릭하면 &amp;:active { background-color: rgb(71, 71, 231); color: white; } }}li 태그가 active 상태(마우스 클릭 상태)가 되면 스타일이 바뀌도록 정하고 싶으면 li:active{}를 사용할 수도 있지만, nesting 문법을 사용해 li 안에 &amp;:active를 사용할수도 있다.alert 박스 만들기조건) mixin/include/extend 문법을 이용해 여러 색상의 박스를 만든다.%alert-box { border-radius: 5px; padding: 10px; margin: 10px;}@mixin design-alert($bg-color, $f-color) { background-color: $bg-color; color: $f-color;}.green-alert { @extend %alert-box; @include design-alert(rgb(192, 243, 192), darkgreen);}위처럼 공통 수치로 들어갈 요소들은 임시클래스 %로 빼주고 각각의 alert-box에 @extend로 넣어준다.그리고 @mixin을 이용해 각각의 박스에서 다르게 적용될 요소의 스타일을 구현해준다.column 레이아웃 직접 만들어보기html 코드가 이렇게 있을 때&lt;div class=\"row\"&gt; &lt;div class=\"col-6\"&gt;1번입니다&lt;/div&gt; &lt;div class=\"col-6\"&gt;2번입니다&lt;/div&gt;&lt;/div&gt;css 코드를 이렇게 주면 된다..row { .col-6 { float: left; width: 50%; padding: 10px; background-color: #eee; border: 1px solid lightgray; }}그런데 원래 width를 50%로 주면 반반 차지해서 1행 2열로 나타나야 하는데 padding을 주는 순간 2행 1열이 되어버린다. 이럴때는 해당 태그에 box-sizing: border-box;를 주면 된다.(여기서는 div 태그에)만약 1행 3열을 하고싶다면 width에 (100%/3)이나 33.33%를 주면 된다!" } ]
